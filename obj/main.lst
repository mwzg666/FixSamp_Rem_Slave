C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\obj\main.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE main.c XSMALL OPTIMIZE(0,SPEED) BROWSE INCDIR(.\Ads1110;.\Flash;.\mcp4
                    -725;.\IIC;.\MwPro;.\Uart;.\Lcd;.\ModBus;.\Temperaturn) PRINT(.\obj\main.lst) OBJECT(.\obj\main.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include "mcp4725.h"
    3          #include "Lcd.h"
    4          #include "LcdApp.h"
    5          #include "ModBus.h"
    6          #include "Temper.h"
    7          #include "FlowMeter.h"
    8          #include "ModBusDev.h"
    9          #include "ModBusHost.h"
   10          
   11          
   12          BYTE code VERSION = 101;  // V1.0.0
   13          
   14          BYTE xdata StrTmp[64] = {0};
   15          //BYTE xdata Valve[8] = {0};
   16          
   17          BYTE ChannelError[FLOW_METER_CNT] ={0};
   18          
   19          #define Log //((CSampDemoDlg *)theApp.m_pMainWnd)->AddLog
   20          
   21          #define PARAM_SIGN  0x3132
   22          SYS_PARAM xdata SysParam;
   23          RUN_STATUS xdata RunStatus;
   24          REM_REGADDR xdata RemRegAddr;
   25          REMRUN_STATUS xdata RemRunStatus;
   26          
   27          float SimFlow = 35.0;
   28          
   29          u16 SendFlowTim = 0;    //读流量计开始时间
   30          BYTE SendFlowFlag = 0;  //读流量计开始标志
   31          
   32          u16 DelayCount = 0;   
   33          BYTE Delayflag = 0;  
   34          
   35          BYTE RemAckOut = 0;    //远程控制从机响应超时标志
   36          u16 RemAckTimout = 0;   //远程控制从机响应超时时间 
   37          
   38          u16 LcdBusyTim = 0;
   39          BYTE LcdBusyFlag = 0;
   40          BYTE ChNum = 1;
   41          
   42          BYTE g_Output[OUT_IO_COUNT]      = {0,0,0,0,0,0,0,0,0,0,0,0,0};   // 上电蓝灯亮
   43          BYTE g_OutStatus[OUT_IO_COUNT]   = {0,0,0,0,0,0,0,0,0,0,0,0,0};
   44          
   45          BYTE PageSwitch = 0;                              //远程控制界面选择
   46          
   47          BYTE RemPage = 0;
   48          BYTE RemStart = 0;
   49          BYTE RemStop = 0;
   50          
   51          // Clear Rem ARM 
   52          BYTE xdata Remchenable[CHANNLE_NUM] = {0};
   53          BOOL xdata Remchflag[CHANNLE_NUM] = {0};
   54          WORD Remchtim = 0;
   55          BOOL ValveIOFlag = false;
   56          BYTE ChannelStop = 0;
   57          
   58          u16  Timer0Cnt = 0;
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 2   

   59          
   60          BYTE g_Key_Confrom  = 0; 
   61          BYTE g_Key_Power  = 0; 
   62          BYTE g_Key_Input  = 0; 
   63          BYTE Input_Status = 0;
   64          
   65          WORD gRunTime = 0;
   66          
   67          void DebugMsg(char *msg)
   68          {
   69   1          BYTE len = (BYTE)strlen(msg);
   70   1          //Uart1Send((BYTE *)msg,len);
   71   1      }
   72          
   73          void DebugInt(int msg)
   74          {
   75   1          memset(StrTmp,0,64);
   76   1          sprintf(StrTmp,"%x\r\n",msg);
   77   1          DebugMsg(StrTmp);
   78   1      }
   79          
   80          void DumpCmd(BYTE *dat, BYTE len)
   81          {
   82   1          BYTE i;
   83   1          memset(StrTmp,0,64);
   84   1          for (i=0;i<len;i++)
   85   1          {
   86   2              if (strlen(StrTmp) >= 60)
   87   2              {
   88   3                  break;
   89   3              }
   90   2              sprintf(&StrTmp[i*3], "%02X ", dat[i]);
   91   2          }
   92   1          sprintf(&StrTmp[i*3], "\r\n");
   93   1          DebugMsg(StrTmp);
   94   1      }
   95          
   96          
   97          void Error()
   98          {
   99   1          while(1)
  100   1          {
  101   2              RUN_LED(1);
  102   2              Delay(50);
  103   2              RUN_LED(0);
  104   2              Delay(50);
  105   2          }
  106   1          
  107   1      }
  108          
  109          
  110          void SysInit()
  111          {
  112   1          HIRCCR = 0x80;           // 启动内部高速IRC
  113   1          while(!(HIRCCR & 1));
  114   1          CLKSEL = 0;              
  115   1      }
  116          
  117          void IoInit()
  118          {
  119   1          EAXFR = 1;
  120   1          WTST = 0;   //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
  121   1      
  122   1          P0M1 = 0x00;   P0M0 |= (1<<4) ;                     // P0.0 P0.1 P0.4 推挽输出
  123   1          P1M1 = (1<<4)|(1<<3);   P1M0 = 0x00;                       //设置为准双向口
  124   1          P2M1 = 0x00;   P2M0 |= 0x00;                      // P2.2 推挽输出
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 3   

  125   1          P3M1 = 0x00;   P3M0 |= (1<<2)|(1<<3)|(1<<4);        //设置为准双向口
  126   1          P4M1 = 0x00;   P4M0 = 0x00;                       //设置为准双向口
  127   1          P5M1 = 0x00;   P5M0 |= (1<<0) | (1<<2);             //设置为准双向口
  128   1          P6M1 = 0x00;   P6M0 |= (1<<7);     //设置为准双向口
  129   1          P7M1 = 0x00;   P7M0 = 0x00;                         //设置为准双向口
  130   1      }
  131          
  132          
  133          void SensorInit()
  134          {
  135   1          // P1.0 -- 下降缘中断
  136   1          P1IM0 = 0;
  137   1          P1IM1 = 0;
  138   1      
  139   1          // 优先级2
  140   1          //PIN_IP  |= (1<<1);
  141   1          PINIPH |= (1<<1);
  142   1          //P1_IP  = 1; // |= (1<<1);
  143   1          //P1_IPH = 1; //|= (1<<1);
  144   1      
  145   1          // 允许中断
  146   1          P1INTE |= (1<<0) | (1<<1) | (1<<4) | (1<<5);
  147   1      }
  148          
  149          
  150          
  151          void Timer0Init()
  152          {
  153   1          AUXR = 0x00;    //Timer0 set as 12T, 16 bits timer auto-reload, 
  154   1          TH0 = (u8)(Timer0_Reload / 256);
  155   1          TL0 = (u8)(Timer0_Reload % 256);
  156   1          ET0 = 1;    //Timer0 interrupt enable
  157   1          TR0 = 1;    //Tiner0 run
  158   1          
  159   1          // 中断优先级3
  160   1          PT0  = 1;
  161   1          PT0H = 1;
  162   1      }
  163          
  164          // 10ms 中断一下
  165          void Timer0Int (void) interrupt 1
  166          {
  167   1          Timer0Cnt ++;
  168   1         
  169   1          if(Delayflag)
  170   1          {
  171   2              DelayCount -= 10;
  172   2              if(!DelayCount)
  173   2              {
  174   3                  Delayflag = 0;
  175   3              }
  176   2          }
  177   1      }
  178          
  179          #if 0
               // 公用中断服务程序
               void CommInt (void) interrupt 13
               {
                   u8 intf =  P1INTF;
                   
                   if (intf)
                   {
                       P1INTF = 0;
               
                       if (intf & (1<<0))  // P1.0 中断
                       {
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 4   

                           Counter[0] ++;
                       }
               
                       if (intf & (1<<1))  // P1.1 中断
                       {
                           Counter[1] ++;
                       }
               
                       if (intf & (1<<4))  // P1.4 中断
                       {
                           Counter[2] ++;
                       }
               
                       if (intf & (1<<5))  // P1.5 中断
                       {
                           Counter[3] ++;
                       }
                   }
                   
               }
               #endif
  212          
  213          //========================================================================
  214          // 函数名称:void OutCtl(alt_u8 id, alt_u8 st)
  215          // 函数功能:IO输出控制 
  216          // 入口参数: @id：控制IO序号 @st：IO口上一个状态
  217          // 函数返回: 无
  218          // 当前版本: VER1.0
  219          // 修改日期: 2023
  220          // 当前作者: 
  221          // 其他备注: 
  222          //========================================================================
  223          
  224          void OutCtl(alt_u8 id, alt_u8 st)
  225          {
  226   1          if (g_OutStatus[id] == st)
  227   1          {
  228   2              return;
  229   2          }
  230   1      
  231   1          g_OutStatus[id] = st;
  232   1          
  233   1          switch(id)
  234   1          {   
  235   2              case LIGHT_BLUE: 
  236   2              {
  237   3                  (st)? BLU_LIGHT(1) : BLU_LIGHT(0); 
  238   3                  break;
  239   3              }
  240   2          
  241   2              case LIGHT_YELLOW: 
  242   2              {
  243   3                  (st)? YEL_LIGHT(1):YEL_LIGHT(0);
  244   3                  break;
  245   3              }
  246   2      
  247   2              case GAS_BUMP:      //泵
  248   2              {
  249   3                  (st)? BUMP_M(1) : BUMP_M(0);
  250   3                  break;
  251   3              }
  252   2      
  253   2              case EX_FAN:        //风扇
  254   2              {
  255   3                  (st)? FANS_M(1) : FANS_M(0);
  256   3                  break;
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 5   

  257   3              }
  258   2      
  259   2              case ALARM_SOUND:   //报警
  260   2              {
  261   3                  (st)? ALARM(1) : ALARM(0);       
  262   3                  break;
  263   3              }
  264   2      
  265   2              case VALVE_0:   
  266   2              {
  267   3                  (st)? VALVE0(1) : VALVE0(0);       
  268   3                  break;
  269   3              }
  270   2      
  271   2              case VALVE_1:   
  272   2              {
  273   3                  (st)? VALVE1(1) : VALVE1(0);       
  274   3                  break;
  275   3              }  
  276   2      
  277   2              case VALVE_2:   
  278   2              {
  279   3                  (st)? VALVE2(1) : VALVE2(0);       
  280   3                  break;
  281   3              }
  282   2      
  283   2              case VALVE_3:   
  284   2              {
  285   3                  (st)? VALVE3(1) : VALVE3(0);       
  286   3                  break;
  287   3              }   
  288   2      
  289   2              case VALVE_4:   
  290   2              {
  291   3                  (st)? VALVE4(1) : VALVE4(0);       
  292   3                  break;
  293   3              }
  294   2      
  295   2              case VALVE_5:   
  296   2              {
  297   3                  (st)? VALVE5(1) : VALVE5(0);       
  298   3                  break;
  299   3              }   
  300   2      
  301   2              case VALVE_6:   
  302   2              {
  303   3                  (st)? VALVE6(1) : VALVE6(0);       
  304   3                  break;
  305   3              }
  306   2      
  307   2              case VALVE_7:   
  308   2              {
  309   3                  (st)? VALVE7(1) : VALVE7(0);       
  310   3                  break;
  311   3              }   
  312   2          }
  313   1      
  314   1          
  315   1      }
  316          
  317          void OutFlash(alt_u8 id)
  318          {
  319   1          static alt_u16 OutTimer[OUT_IO_COUNT] = {0,0,0,0,0,0,0,0,0,0,0,0,0};
  320   1          if (OutTimer[id] ++ > LED_FLASH_TIME/10)
  321   1          {
  322   2              OutTimer[id] = 0;
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 6   

  323   2              if (g_OutStatus[id] == 1)
  324   2              {
  325   3                  OutCtl(id, 0);
  326   3              }
  327   2              else
  328   2              {
  329   3                  OutCtl(id, 1);
  330   3              }
  331   2          }
  332   1      }
  333          
  334          void IoCtlTask()
  335          {
  336   1          alt_u8 i;
  337   1          for (i=0;i<OUT_IO_COUNT;i++)
  338   1          {
  339   2              if (g_Output[i] == 2)
  340   2              {
  341   3                  OutFlash(i);
  342   3              }
  343   2              else
  344   2              {
  345   3                  OutCtl(i, g_Output[i]);
  346   3              }
  347   2          }
  348   1      }
  349          
  350          // 板载指示灯
  351          void RunLed(u16 dt)
  352          {   
  353   1          static u16 tm = 0;
  354   1          u16 to = 3000;
  355   1          tm += dt;
  356   1      
  357   1          if (tm > to)
  358   1          {
  359   2              tm = 0;
  360   2              RUN_LED(0);
  361   2          }
  362   1          else if (tm > (to-100))
  363   1          {
  364   2              RUN_LED(1);
  365   2          }
  366   1      }
  367          
  368          
  369          
  370          void Task1s()
  371          {
  372   1          static BYTE tm = 0;
  373   1      
  374   1          CLR_WDT = 1;  // 喂狗
  375   1          tm++;
  376   1          if(tm == 10)
  377   1          {
  378   2              ADC_Temp();
  379   2              //SyncModBusDev();
  380   2              tm = 0;
  381   2          } 
  382   1          
  383   1          if((tm == 6)||(tm == 3))
  384   1          {
  385   2              GetRetCode();
  386   2          }
  387   1          
  388   1          if(tm == 9)
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 7   

  389   1          {
  390   2              if (RunStatus.Running)
  391   2              {  
  392   3                  DevRun();
  393   3              }
  394   2          }
  395   1      
  396   1      }
  397          
  398          
  399          void TimerTask()
  400          {
  401   1          u16 delta = 0;
  402   1          static u16 Time1s = 0;
  403   1          static u16 RemTime = 0;
  404   1          if (Timer0Cnt)
  405   1          {
  406   2              delta = Timer0Cnt * 10;
  407   2              Timer0Cnt = 0;
  408   2      
  409   2              Time1s += delta;
  410   2              if (Time1s >= 100)
  411   2              {
  412   3                  Time1s = 0;
  413   3                  Task1s();
  414   3              }
  415   2              
  416   2              if (RX2_Cnt > 0)
  417   2              {
  418   3                  Rx2_Timer += delta;
  419   3              }
  420   2      
  421   2              if(RX3_Cnt > 0)
  422   2              {
  423   3                  Rx3_Timer += delta;
  424   3              }
  425   2              
  426   2              if(RX4_Cnt > 0)
  427   2              {
  428   3                  Rx4_Timer += delta;
  429   3                  
  430   3              }
  431   2              
  432   2              SendFlowTim += delta;
  433   2              if(SendFlowTim > 220)
  434   2              {
  435   3                  SendFlowTim = 0;
  436   3                  SendFlowFlag = 1;
  437   3              }
  438   2              
  439   2              if(RemAckOut)
  440   2              {
  441   3                  RemAckTimout += delta;
  442   3                  if(RemAckTimout > 3000)
  443   3                  {
  444   4                      RemAckTimout = 0;
  445   4                      SysParam.RemCtlFlag = false;
  446   4                  }
  447   3                      
  448   3              }  
  449   2              
  450   2              if (gRunTime < 5000)
  451   2              {
  452   3                  gRunTime += delta;
  453   3              }
  454   2      
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 8   

  455   2              //if (g_CommIdleTime < 300)
  456   2              //{
  457   2                  //g_CommIdleTime += delta;
  458   2              //}
  459   2      
  460   2              #ifdef IRDA_FUN
                       if (IrDAStart == 1)
                       {
                           IrDATimer += delta;
                       }
                       #endif
  466   2      
  467   2              RunLed(delta);
  468   2              IoCtlTask();
  469   2                      
  470   2              GetValve();
  471   2              if(SysParam.RemCtlFlag)
  472   2              {
  473   3                  ShowRemCh();
  474   3              }
  475   2          }
  476   1      }
  477          
  478          void delay_ms(u16 ms)
  479          {
  480   1          DelayCount = ms;
  481   1          Delayflag = 1;  
  482   1          while(Delayflag);        
  483   1      }
  484          
  485          
  486          void Delay(WORD ms)
  487          {
  488   1          WORD t = 1000;
  489   1          while(ms--)
  490   1          {
  491   2              for (t=0;t<1000;t++) ;
  492   2          }
  493   1      }
  494          
  495          
  496          WORD ParamCheck(BYTE *buf, WORD len)
  497          {
  498   1          WORD dwSum = 0;
  499   1          WORD i;
  500   1      
  501   1          for (i = 0; i < len; i++)
  502   1          {
  503   2              dwSum += buf[i];
  504   2          }
  505   1      
  506   1          return dwSum;
  507   1      }
  508          
  509          /*
  510          void DefSenParam()
  511          {
  512              BYTE i;
  513              for (i=0; i<SENSOR_COUNT; i++)
  514              {
  515                  SysParam.SenParam[i].LOW_REVISE_COE_A = 1;
  516                  SysParam.SenParam[i].LOW_REVISE_COE_B = 1;
  517                  SysParam.SenParam[i].LOW_REVISE_COE_C = 1;
  518          
  519                  SysParam.SenParam[i].HIG_REVISE_COE_A = 1;
  520                  SysParam.SenParam[i].HIG_REVISE_COE_B = 1;
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 9   

  521                  SysParam.SenParam[i].HIG_REVISE_COE_C = 1;
  522          
  523                  SysParam.SenParam[i].SUPER_REVISE_COE_A = 1;
  524                  SysParam.SenParam[i].SUPER_REVISE_COE_B = 1;
  525                  SysParam.SenParam[i].SUPER_REVISE_COE_C = 1;
  526          
  527                  SysParam.SenParam[i].DET_THR_1 = 500;
  528                  SysParam.SenParam[i].DET_THR_2 = 150;
  529                  SysParam.SenParam[i].DET_THR_3 = 150;
  530          
  531                  SysParam.SenParam[i].DET_TIME = 1000;
  532                  SysParam.SenParam[i].HV_THR = 1000;
  533              }
  534          }
  535          */
  536          
  537          /*
  538          void DefSenAlarm()
  539          {
  540              BYTE i;
  541              for (i=0; i<SENSOR_COUNT; i++)
  542              {
  543                  SysParam.AlmParam[i].DOSE_RATE_ALARM_1 = 300;
  544                  SysParam.AlmParam[i].DOSE_RATE_ALARM_2 = 400;
  545                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_1 = 300;
  546                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_2 = 400;
  547                  SysParam.AlmParam[i].INVALID_ALRAM_1 = 8000;
  548                  SysParam.AlmParam[i].INVALID_ALRAM_2 = 10000;
  549              }
  550          }
  551          */
  552          
  553          void ReadParam()
  554          {
  555   1          EEPROM_read(0, (BYTE *)&SysParam, sizeof(SYS_PARAM));
  556   1      
  557   1          #if 0
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(SYS_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_SENSOR_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_ALRAM_PARA));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(float));
                   DebugMsg((char *)StrTmp);
                   
                   //Rs485Send((BYTE *)&SysParam, sizeof(SYS_PARAM));
                   
                   
                   if (SysParam.Sign != PARAM_SIGN)
                   {
                       DebugMsg("Sign error. \r\n");
                   }
               
                   if (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2))
                   {
                       DebugMsg("Param Check error. \r\n");
                   }
                   #endif
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 10  

  587   1      
  588   1         
  589   1          if ( (SysParam.Sign != PARAM_SIGN) ||
  590   1               (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2)) )
  591   1          {
  592   2              //SysParam.Sign = PARAM_SIGN;
  593   2              //SysParam.Address = 1;
  594   2              ParamDef();
  595   2              //DefSenParam();
  596   2              //DefSenAlarm();
  597   2              WriteParam();
  598   2      
  599   2              //DebugMsg("Def Param. \r\n");
  600   2          }
  601   1      }
  602          
  603          
  604          void WriteParam()
  605          {
  606   1          EA = 0;    
  607   1          
  608   1          EEPROM_SectorErase(0);
  609   1          EEPROM_SectorErase(512);
  610   1          SysParam.Sum = ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2);
  611   1          if (!EEPROM_write(0, (BYTE *)&SysParam, sizeof(SYS_PARAM)))
  612   1          {
  613   2              Error();
  614   2          }
  615   1          //printf("Write34= OK\r\n");
  616   1          EA = 1;     //打开总中断
  617   1      }
  618          
  619          BYTE GetInput()
  620          {
  621   1          // 当前只有一个开关机状态 P2.1
  622   1          static BYTE his = LOCK_BIT();
  623   1          BYTE st = POWER_LOCK();
  624   1      
  625   1          if (st != his)
  626   1          {
  627   2              Delay(50);
  628   2              if ( st == POWER_LOCK() )
  629   2              {
  630   3                  his = st;
  631   3                  return st;
  632   3              }
  633   2          }
  634   1      
  635   1          return 0xFF;
  636   1      }
  637          
  638          
  639          void PowerOff()
  640          {
  641   1          PW_MAIN(0);
  642   1      
  643   1          while(1)
  644   1          {
  645   2              ;
  646   2          }
  647   1      }
  648          
  649          void HndInput()
  650          {
  651   1          static bool em = false;
  652   1          if(STOP_M() == 0)
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 11  

  653   1          {
  654   2              Delay(10);
  655   2              if (STOP_M() == 0)
  656   2              {
  657   3                  if (RunStatus.Running)
  658   3                  {
  659   4                      StopSamp(false);
  660   4                  }
  661   3              }
  662   2      
  663   2              if (em == false)
  664   2              {
  665   3                  em = true;
  666   3                  ShowEmStop(em);
  667   3              }
  668   2          }
  669   1          else
  670   1          {
  671   2              if (em)
  672   2              {
  673   3                  em = false;
  674   3                  ShowEmStop(em);
  675   3              }
  676   2          }
  677   1      }
  678          
  679          /*
  680          void ReportInput()
  681          {
  682              BYTE PwOff = POWER_OFF;
  683              
  684              if (g_CommIdleTime > 200)
  685              {
  686                  if (g_Key_Confrom)
  687                  {
  688                      g_Key_Confrom = 0;
  689                      SendPcCmd(0, CMD_CERTAINKEY, NULL, 0);
  690                      return;
  691                  }
  692          
  693                  if (g_Key_Power)
  694                  {
  695                      g_Key_Power = 0;
  696                      SendPcCmd(0, CMD_POWER, &PwOff, 1);
  697                      return;
  698                  }
  699          
  700                  #if 0
  701                  if (g_Key_Input)
  702                  {
  703                      g_Key_Input = 0;
  704                      SendPcCmd(0, CMD_INPUT, &Input_Status, 1);
  705                  }
  706                  #endif
  707              }
  708          }
  709          */
  710          
  711          void LedInit()
  712          {
  713   1          // 初始状态都为0
  714   1      
  715   1          // 指示灯
  716   1          YEL_LIGHT(0);   // 黄灯
  717   1          BLU_LIGHT(0);   // 蓝灯
  718   1          
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 12  

  719   1          CloseValve();   // 电磁阀
  720   1          BUMP_M(0);      // 泵
  721   1          FANS_M(0);      // 风扇
  722   1          ALARM(0);       // 报警音
  723   1      }
  724          
  725          
  726          void ParamDef()
  727          {
  728   1          BYTE i;
  729   1          
  730   1          SysParam.Sign     = PARAM_SIGN;
  731   1          SysParam.Address = 1;
  732   1          SysParam.BkLight = 50;
  733   1      
  734   1          SysParam.SampMode = MODE_TIME;
  735   1          SysParam.SampTime = 5;  
  736   1          SysParam.SampVol   = 2;
  737   1          SysParam.AlarmThres   = 10;
  738   1          for (i=0;i<CHANNLE_NUM;i++)
  739   1          {
  740   2              SysParam.SampFlow[i] = 35;
  741   2              SysParam.Channel_SampMode[i] = MODE_NOCHANNEL;
  742   2              SysParam.Channel_SampFlowVol[i] = 2;
  743   2          }
  744   1      
  745   1          SysParam.Enable = 0x00;
  746   1          SysParam.ChModeCtl = 0x00;
  747   1              SysParam.RemCtlFlag = false;
  748   1          RemRunStatus.RemRun = false; 
  749   1          RemRunStatus.HostRun = true;
  750   1              ChannelStop = 0;
  751   1      }
  752          
  753          void SaveParam()
  754          {
  755   1          //CString t;
  756   1          //t.Format(_T("SaveParam: %02X\r\n"), SysParam.Enable);
  757   1          //Log(t);
  758   1          //DebugMsg("123");
  759   1          WriteParam();
  760   1      }
  761          
  762          
  763          void UpdataUI()
  764          {
  765   1          BYTE i;
  766   1          for (i=0;i<CHANNLE_NUM;i++)
  767   1          {
  768   2              ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
  769   2          }
  770   1          ShowStatus();
  771   1          Delay(200);
  772   1          StatusColor(true);
  773   1      }
  774          
  775          void InitLcd()
  776          {   
  777   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  778   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  779   1          memset(&RealFlow, 0, sizeof(RealFlow));
  780   1          
  781   1          ModeHint();
  782   1          Delay(200);
  783   1          HideModule(MP_HINT_END);
  784   1          Delay(200);
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 13  

  785   1          UpdataUI();    
  786   1          Delay(200);
  787   1          SendParam();
  788   1          Delay(200);
  789   1              SendChannelParam();
  790   1              Delay(200);
  791   1          SetBkLight(false);
  792   1          Delay(200);
  793   1          ShowDevInfo();
  794   1          Delay(200);
  795   1      }
  796          
  797          
  798          void GetFlow()
  799          {
  800   1          BYTE i;
  801   1          WORD  w;
  802   1          DWORD d;
  803   1      
  804   1          
  805   1          for (i=0;i<CHANNLE_NUM;i++)
  806   1          {
  807   2      //        if (SysParam.Enable & (1<<i))
  808   2      //        {
  809   2                  RunStatus.Flow[i] = RealFlow[i].val;  // 模拟 -- 实际要从流量计中读取
  810   2                  w = (WORD)(RunStatus.Flow[i]*10);
  811   2                  RunInfo.ChFlow[i].Flow = SwWord(w);
  812   2                  
  813   2                  RunStatus.Volume[i] =  RealFlow[i].Totol; 
  814   2                  w = (WORD)(RunStatus.Volume[i]*10);
  815   2                  RunInfo.ChFlow[i].Vol = SwWord(w);
  816   2      //        }
  817   2          }
  818   1      
  819   1          // 总流量
  820   1          RunStatus.TotleFlow = RealFlow[8].val;
  821   1          d = (DWORD)(RealFlow[8].val*10);
  822   1          RunInfo.TotFlow.Flow = SwDWord(d);
  823   1      
  824   1          // 总体积
  825   1          RunStatus.TotleVol = RealFlow[8].Totol;
  826   1          d = (DWORD)(RealFlow[8].Totol*10);
  827   1          RunInfo.TotFlow.Vol   = SwDWord(d);
  828   1      }
  829          
  830          void StartSamp()
  831          {
  832   1          BYTE i = 0;
  833   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  834   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  835   1          memset(&RealFlow, 0, sizeof(RealFlow));
  836   1          SysParam.ChModeCtl = 0x00;
  837   1          RemRunStatus.HostRun = true;
  838   1          RunStatus.Running = true;
  839   1          g_Output[LIGHT_BLUE] = 1;
  840   1          //CheckValve();
  841   1          OpenPump();
  842   1          memcpy(HisAlarm,ChannelAlarm,CHANNLE_NUM);
  843   1          ShowStatus();
  844   1          StatusColor(true);
  845   1          //g_Output[ALARM_SOUND] = 0; 
  846   1      
  847   1          if(!SysParam.RemCtlFlag)
  848   1          {
  849   2              SetStartBtn(0);
  850   2          }
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 14  

  851   1      
  852   1      }
  853          
  854          void StopSamp(bool Auto)
  855          {
  856   1          BYTE i = 0;
  857   1          ClosePump();
  858   1          memset(RealFlow,0, sizeof(RealFlow));
  859   1              ChannelStop = 0;
  860   1          RunStatus.Running = false;
  861   1          g_Output[LIGHT_BLUE] = 0;
  862   1          g_Output[LIGHT_YELLOW] = 0; 
  863   1          g_Output[ALARM_SOUND] = 0; 
  864   1          for (i=0;i<CHANNLE_NUM;i++)
  865   1          {
  866   2              ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
  867   2          }
  868   1         
  869   1          if(!SysParam.RemCtlFlag)
  870   1          {
  871   2              SetStartBtn(1);  // 按钮自动变为“开始”
  872   2          }
  873   1          if (Auto)  // 自动结束
  874   1          {
  875   2              // 显示取样结束提示框
  876   2              ShowModule(MP_HINT_END, REG_HINT_END);
  877   2                      //Delay(200);
  878   2          }
  879   1              SaveParam();
  880   1      }
  881          
  882          
  883          void CheckModeStop()
  884          {
  885   1              BYTE i = 0;
  886   1              static BYTE sta = 0; 
  887   1          if(SysParam.Enable == 0)
  888   1          {
  889   2              RemRunStatus.HostRun = false;
  890   2              if(SysParam.RemCtlFlag)
  891   2              {
  892   3                  StopSamp(false);
  893   3              }
  894   2              else
  895   2              {
  896   3                  StopSamp(true);
  897   3              }
  898   2          }
  899   1      }
  900          
  901          // 定时模式
  902          void TimingMode()
  903          {
  904   1          BYTE i = 0,j = 0;
  905   1          for(i = 0;i<CHANNLE_NUM;i++)
  906   1          {
  907   2             
  908   2              if(SysParam.Channel_SampMode[i] == MODE_VOL)
  909   2              {
  910   3                  if(RunStatus.Volume[i] >= (SysParam.Channel_SampFlowVol[i]))
  911   3                  {
  912   4                      if(!SysParam.RemCtlFlag)
  913   4                                  {
  914   5                                      SysParam.Enable &= ~(1<<i);   
  915   5                                  }               
  916   4                      SysParam.ChModeCtl |= (1<<i);
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 15  

  917   4                                      
  918   4                  }
  919   3              }
  920   2              else if(SysParam.Channel_SampMode[i] == MODE_TIME)
  921   2              {
  922   3                  if (RunStatus.RunTime[i] >= ((DWORD)SysParam.Channel_SampFlowVol[i]) * 60)
  923   3                  {
  924   4                              if(!SysParam.RemCtlFlag)
  925   4                                  {
  926   5                              SysParam.Enable &= ~(1<<i);
  927   5                              }
  928   4                      SysParam.ChModeCtl |= (1<<i);
  929   4                  }
  930   3              }
  931   2                      else
  932   2              {
  933   3                  if (RunStatus.RunTime[8] >= ((DWORD)SysParam.SampTime) * 60)
  934   3                  {
  935   4                      if(!SysParam.RemCtlFlag)
  936   4                                  {
  937   5                              SysParam.Enable &= ~(1<<i);
  938   5                              }
  939   4                      SysParam.ChModeCtl |= (1<<i);
  940   4      
  941   4                  }
  942   3              }
  943   2          }
  944   1          CheckModeStop();
  945   1      }
  946          
  947          void Channel_ManMode()
  948          {
  949   1          BYTE i = 0;
  950   1          for(i = 0;i<CHANNLE_NUM;i++)
  951   1          {
  952   2              if(SysParam.Channel_SampMode[i] == MODE_VOL)
  953   2              {
  954   3                  if(RunStatus.Volume[i] >= (SysParam.Channel_SampFlowVol[i]))
  955   3                  {
  956   4                      if(!SysParam.RemCtlFlag)
  957   4                                  {
  958   5                              SysParam.Enable &= ~(1<<i);
  959   5                              }
  960   4                      SysParam.ChModeCtl |= (1<<i);
  961   4                  }
  962   3              }
  963   2              else if(SysParam.Channel_SampMode[i] == MODE_TIME)
  964   2              {
  965   3                  if (RunStatus.RunTime[8] >= ((DWORD)SysParam.Channel_SampFlowVol[i]) * 60)
  966   3                  {
  967   4                      if(!SysParam.RemCtlFlag)
  968   4                                  {
  969   5                              SysParam.Enable &= ~(1<<i);
  970   5                              }
  971   4                      SysParam.ChModeCtl |= (1<<i);
  972   4                  }
  973   3              }
  974   2          }
  975   1          CheckModeStop();
  976   1      }
  977          
  978          // 定量模式
  979          void VolumeMode()
  980          {
  981   1          BYTE i = 0,j = 0;
  982   1          for(i = 0;i<CHANNLE_NUM;i++)
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 16  

  983   1          {
  984   2              
  985   2              if(SysParam.Channel_SampMode[i] == MODE_VOL)
  986   2              {
  987   3                  if(RunStatus.Volume[i] >= (SysParam.Channel_SampFlowVol[i]))
  988   3                  {
  989   4                      if(!SysParam.RemCtlFlag)
  990   4                                  {
  991   5                              SysParam.Enable &= ~(1<<i);
  992   5                              }
  993   4                      SysParam.ChModeCtl |= (1<<i);
  994   4                  }
  995   3              }
  996   2              else if(SysParam.Channel_SampMode[i] == MODE_TIME)
  997   2              {
  998   3                  if (RunStatus.RunTime[i] >= ((DWORD)SysParam.Channel_SampFlowVol[i]) * 60)
  999   3                  {
 1000   4                      if(!SysParam.RemCtlFlag)
 1001   4                                  {
 1002   5                              SysParam.Enable &= ~(1<<i);
 1003   5                              }
 1004   4                      SysParam.ChModeCtl |= (1<<i);
 1005   4                  }
 1006   3              }
 1007   2                      else
 1008   2              {
 1009   3                      //ChannelStop |= (1<<i);
 1010   3                  if (RunStatus.Volume[i] >= SysParam.SampVol)
 1011   3                  {
 1012   4                      if(!SysParam.RemCtlFlag)
 1013   4                                  {
 1014   5                              SysParam.Enable &= ~(1<<i);
 1015   5                              }
 1016   4                      SysParam.ChModeCtl |= (1<<i);
 1017   4                  }
 1018   3              }
 1019   2          }
 1020   1          CheckModeStop();
 1021   1      }
 1022          
 1023          
 1024          void RunCheck()
 1025          {
 1026   1          switch (SysParam.SampMode)
 1027   1          {
 1028   2              case MODE_TIME:  TimingMode();  break;
 1029   2              case MODE_VOL:   VolumeMode();  break;
 1030   2              default: Channel_ManMode();break;
 1031   2          }
 1032   1              //Delay(200);
 1033   1              SendParam();
 1034   1              
 1035   1      //      SendChannelParam();
 1036   1      //      Delay(200);
 1037   1      }
 1038          
 1039          void AbnorAlaerm()
 1040          {   
 1041   1          BYTE i;
 1042   1          bool HaveAlarm = false;
 1043   1      
 1044   1          for(i = 0;i < CHANNLE_NUM;i++)
 1045   1          {
 1046   2              if( (ChannelAlarm[i] == ALM_FLOW_ABNOR) ||
 1047   2                  (ChannelAlarm[i] ==  ALM_FLOW_LOW) || 
 1048   2                  (ChannelAlarm[i] == ALM_FLOW_HIGH)  )
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 17  

 1049   2              {
 1050   3                  HaveAlarm = true;
 1051   3                  break;
 1052   3              }
 1053   2          }
 1054   1      
 1055   1          if (HaveAlarm)
 1056   1          {
 1057   2              //printf("HAveALM_true\r\n");
 1058   2              g_Output[LIGHT_YELLOW] = 1;
 1059   2              g_Output[ALARM_SOUND] = 2;
 1060   2          }
 1061   1          else
 1062   1          {
 1063   2              //printf("HAveALM_false\r\n");
 1064   2              g_Output[LIGHT_YELLOW] = 0;
 1065   2              g_Output[ALARM_SOUND] = 0;
 1066   2          }
 1067   1      }
 1068          void CheckAlarm()
 1069          {
 1070   1          BYTE i;
 1071   1          float flow = 0;
 1072   1          static BYTE time[8] = {0};
 1073   1          for (i=0;i<CHANNLE_NUM;i++)
 1074   1          {
 1075   2              if (SysParam.Enable & (1<<i))
 1076   2              {
 1077   3                  if(Remchflag[i])
 1078   3                  {
 1079   4                      time[i]++;
 1080   4                      if(time[i] > 2)
 1081   4                      {
 1082   5                          time[i] = 0;
 1083   5                          Remchflag[i] = false;
 1084   5                          flow = RunStatus.Flow[i];
 1085   5                          if (flow > SysParam.SampFlow[i]*(100+SysParam.AlarmThres)/100)
 1086   5                          {
 1087   6                              ChannelAlarm[i] = ALM_FLOW_HIGH;
 1088   6                          }
 1089   5                          else if (flow < SysParam.SampFlow[i]*(100-SysParam.AlarmThres)/100)
 1090   5                          {
 1091   6                              ChannelAlarm[i] = ALM_FLOW_LOW;
 1092   6                          }
 1093   5                          else
 1094   5                          {
 1095   6                              ChannelAlarm[i] = ALM_FLOW_NOR;
 1096   6                          }
 1097   5                      }
 1098   4                  }
 1099   3                  else
 1100   3                  {    
 1101   4                      flow = RunStatus.Flow[i];
 1102   4                      if (flow > SysParam.SampFlow[i]*(100+SysParam.AlarmThres)/100)
 1103   4                      {
 1104   5                          ChannelAlarm[i] = ALM_FLOW_HIGH;
 1105   5                      }
 1106   4                      else if (flow < SysParam.SampFlow[i]*(100-SysParam.AlarmThres)/100)
 1107   4                      {
 1108   5                          ChannelAlarm[i] = ALM_FLOW_LOW;
 1109   5                      }
 1110   4                      else
 1111   4                      {
 1112   5                          ChannelAlarm[i] = ALM_FLOW_NOR;
 1113   5                      }
 1114   4                  }
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 18  

 1115   3                  
 1116   3              }
 1117   2              else
 1118   2              {
 1119   3                  ChannelAlarm[i] = ALM_CH_DISABLE;
 1120   3              }
 1121   2              
 1122   2              if( (ChannelError[i] > 3) && (ChannelAlarm[i] != ALM_CH_DISABLE) )
 1123   2              {
 1124   3                  ChannelAlarm[i] = ALM_FLOW_ABNOR;
 1125   3              }
 1126   2          }
 1127   1          if (memcmp(HisAlarm,ChannelAlarm,CHANNLE_NUM) != 0)
 1128   1          {
 1129   2              // 报警有变化才更新界面
 1130   2              Delay(200);
 1131   2              ShowStatus();
 1132   2              Delay(200);
 1133   2              AbnorAlaerm();
 1134   2              StatusColor(false);
 1135   2      
 1136   2              memcpy(HisAlarm,ChannelAlarm,8);
 1137   2          }
 1138   1      }
 1139          
 1140          // 1秒运行一次
 1141          void DevRun()
 1142          {
 1143   1          BYTE i = 0;
 1144   1          RunStatus.RunTime[8] ++;
 1145   1          for(i = 0;i<CHANNLE_NUM;i++)
 1146   1          {
 1147   2              if(SysParam.Enable &(1<<i))
 1148   2              {
 1149   3                  RunStatus.RunTime[i] ++;
 1150   3              }
 1151   2          }
 1152   1          
 1153   1          // 1. 获取流量
 1154   1          GetFlow();
 1155   1      
 1156   1          // 2. 显示流量和状态
 1157   1          ShowFlow();
 1158   1      
 1159   1              // 4. 根据模式判断是否结束取样
 1160   1          RunCheck();
 1161   1              
 1162   1          // 3. 检查报警状态  
 1163   1          if (RunStatus.RunTime[8] > 10)
 1164   1          {
 1165   2              // 运行时间大于10秒才检测
 1166   2              CheckAlarm();
 1167   2          }
 1168   1          
 1169   1      
 1170   1      //      SendParam();
 1171   1      //      SendChannelParam();
 1172   1      }
 1173          
 1174          
 1175          //获取电磁阀状态
 1176          void GetValve()
 1177          {
 1178   1          BYTE i;
 1179   1          for(i = 0;i<CHANNLE_NUM;i++)
 1180   1          {
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 19  

 1181   2              if(SysParam.Enable & (1<<i))
 1182   2              {
 1183   3                  RemChStatus[i] = 1;
 1184   3                 
 1185   3              }
 1186   2              else
 1187   2              {
 1188   3                  RemChStatus[i] = 0; 
 1189   3                  RunStatus.RunTime[i] = 0;
 1190   3                              RealFlow[i].Totol = 0;
 1191   3              }
 1192   2              if(SysParam.RemCtlFlag)
 1193   2              {
 1194   3                  if(Remchenable[i] != RemChStatus[i])
 1195   3                  {
 1196   4                      Remchenable[i] = RemChStatus[i];
 1197   4                      Remchflag[i] = true;
 1198   4                  }
 1199   3              }
 1200   2          }
 1201   1          
 1202   1              CheckValve();
 1203   1      }
 1204          
 1205          //查询电磁阀状态
 1206          void CheckValve()
 1207          {
 1208   1          BYTE i;
 1209   1          for(i = 0;i<CHANNLE_NUM;i++)
 1210   1          {
 1211   2              if(RemChStatus[i])
 1212   2              {
 1213   3                  switch(i)
 1214   3                  {                            
 1215   4                      case 0 : g_Output[VALVE_0] = 1; break;
 1216   4                      case 1 : g_Output[VALVE_1] = 1; break;
 1217   4                      case 2 : g_Output[VALVE_2] = 1; break;
 1218   4                      case 3 : g_Output[VALVE_3] = 1; break;
 1219   4                      case 4 : g_Output[VALVE_4] = 1; break;
 1220   4                      case 5 : g_Output[VALVE_5] = 1; break;
 1221   4                      case 6 : g_Output[VALVE_6] = 1; break;
 1222   4                      case 7 : g_Output[VALVE_7] = 1; break;  
 1223   4                  }
 1224   3              }
 1225   2              else
 1226   2              {
 1227   3                  switch(i)
 1228   3                  {
 1229   4                      case 0 : g_Output[VALVE_0] = 0; break;
 1230   4                      case 1 : g_Output[VALVE_1] = 0; break;
 1231   4                      case 2 : g_Output[VALVE_2] = 0; break;
 1232   4                      case 3 : g_Output[VALVE_3] = 0; break;
 1233   4                      case 4 : g_Output[VALVE_4] = 0; break;
 1234   4                      case 5 : g_Output[VALVE_5] = 0; break;
 1235   4                      case 6 : g_Output[VALVE_6] = 0; break;
 1236   4                      case 7 : g_Output[VALVE_7] = 0; break;  
 1237   4                  }
 1238   3              }
 1239   2          }
 1240   1      }
 1241          
 1242          //关闭电磁阀
 1243          void CloseValve()
 1244          {
 1245   1          VALVE0(0);
 1246   1          VALVE1(0);
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 20  

 1247   1          VALVE2(0);
 1248   1          VALVE3(0);
 1249   1          VALVE4(0);
 1250   1          VALVE5(0);
 1251   1          VALVE6(0);
 1252   1          VALVE7(0);
 1253   1      }
 1254          // 开启气泵
 1255          void OpenPump()
 1256          {
 1257   1          g_Output[GAS_BUMP] = 1;
 1258   1      }
 1259          
 1260          
 1261          // 停止气泵
 1262          void ClosePump()
 1263          {
 1264   1          //CloseValve();
 1265   1          g_Output[GAS_BUMP] = 0;
 1266   1      }
 1267          
 1268          void SendReadFlowCmd(BYTE ch)
 1269          {
 1270   1          ChannelError[ch-1] ++;
 1271   1          SendReadFlow(ch);    
 1272   1      }
 1273          
 1274          BYTE GetAlarm(BYTE i)
 1275          {
 1276   1          if(ChannelAlarm[i] == ALM_CH_DISABLE)
 1277   1          {
 1278   2              return ALM_CH_DISABLE;
 1279   2          }
 1280   1          else if (ChannelAlarm[i] ==  ALM_FLOW_ABNOR)
 1281   1          {
 1282   2              return ALM_FLOW_ABNOR;
 1283   2          }
 1284   1          
 1285   1          else if (ChannelAlarm[i] ==  ALM_FLOW_HIGH)
 1286   1          {
 1287   2              return ALM_FLOW_HIGH;
 1288   2          }
 1289   1      
 1290   1          else if (ChannelAlarm[i] ==  ALM_FLOW_LOW)
 1291   1          {
 1292   2              return ALM_FLOW_LOW;
 1293   2          }
 1294   1          else
 1295   1          {
 1296   2              return ALM_FLOW_NOR;
 1297   2          }
 1298   1      }
 1299          
 1300          void SyncModBusDev()
 1301          {
 1302   1          BYTE i;
 1303   1          memset(&ModBusParam, 0, sizeof(MODBUS_PARAM));
 1304   1          ModBusParam.Addr = RemRegAddr.SypAddr;
 1305   1          ModBusParam.ChModeCtl = SysParam.ChModeCtl;
 1306   1          ModBusParam.RunStatus = RemRunStatus.HostRun;
 1307   1          for(i = 0;i < 8;i++)    
 1308   1          {
 1309   2              ModBusParam.Alarm[i] = GetAlarm(i);
 1310   2          }
 1311   1          ModBusParam.Address = 2;
 1312   1      }
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 21  

 1313          void FlowTask()
 1314          {
 1315   1          if (RunStatus.Running)
 1316   1          {
 1317   2              if(SendFlowFlag == 1)
 1318   2              {
 1319   3                  SendFlowFlag = 0;
 1320   3                  SendReadFlowCmd(ChNum++);
 1321   3              }
 1322   2              
 1323   2              if (ChNum>9)
 1324   2              {
 1325   3                  ChNum = 1;
 1326   3              }
 1327   2          }
 1328   1      }
 1329          
 1330          void RemPageCtl()
 1331          {
 1332   1          BYTE i = 0;
 1333   1          if(SysParam.RemCtlFlag)
 1334   1          {     
 1335   2              if(!RemPage)
 1336   2              {
 1337   3                  RemPage = 1;
 1338   3                  EnterPage(PAGE_REM);
 1339   3              }
 1340   2             if(RemRunStatus.RemRun)
 1341   2             {
 1342   3                  RemStop = 0;
 1343   3                  if(RemStart == 0)
 1344   3                  {
 1345   4                      StartSamp();
 1346   4                      RemStart++;
 1347   4                  }
 1348   3              }
 1349   2             else
 1350   2             {
 1351   3                  RemStart = 0;
 1352   3                  
 1353   3                  if(RemStop == 0)
 1354   3                  {    
 1355   4                      RemRunStatus.HostRun = true;
 1356   4                      g_Output[ALARM_SOUND] = 0; 
 1357   4                      memset(&RunStatus, 0, sizeof(RUN_STATUS));
 1358   4                      StopSamp(false);
 1359   4                      SendParam();
 1360   4                                      //SendChannelParam();
 1361   4                      ModeHint(); 
 1362   4                      
 1363   4                      RemStop++;
 1364   4                  }
 1365   3              }
 1366   2          }     
 1367   1          else
 1368   1          {
 1369   2              RemStart = 0;
 1370   2              RemStop = 0;
 1371   2              for (i=0;i<CHANNLE_NUM;i++)
 1372   2              {
 1373   3                  Remchflag[i] = false;
 1374   3              }
 1375   2              
 1376   2              if(RemPage)
 1377   2              {   
 1378   3                  RemPage = 0; 
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 22  

 1379   3                  RemRunStatus.RemRun = false;
 1380   3                  SysParam.ChModeCtl = 0x00;
 1381   3                  
 1382   3                  ClosePump();
 1383   3                  memset(&RunStatus, 0, sizeof(RUN_STATUS));
 1384   3                  memset(RealFlow,0, sizeof(RealFlow));
 1385   3                  for(i=0;i<CHANNLE_NUM;i++)
 1386   3                  {
 1387   4                      ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
 1388   4                  }
 1389   3                  g_Output[ALARM_SOUND] = 0; 
 1390   3                  g_Output[LIGHT_BLUE] = 0; 
 1391   3                  g_Output[LIGHT_YELLOW] = 0;
 1392   3                  SendParam();
 1393   3                              //SendChannelParam();
 1394   3                  ModeHint(); 
 1395   3                  EnterPage(PAGE_START);
 1396   3              } 
 1397   2          }
 1398   1      }
 1399          
 1400          
 1401          #if 0
               //远程控制界面切换
               void RemPageCtl()
               {
                   switch(PageSwitch)
                   {
                       case 0:
                       {
                           if(RunStatus.Running)
                           {
                               if(SysParam.RemCtlFlag)
                               {
                                   if(!RemFlag[4])
                                   {
                                       RemFlag[4] = 1;
                                       StartRem[4]++;
                                       EnterPage(PAGE_REM);
                                      
                                   }
                               }
                               else
                               {
                                   if(StartRem[4] != 0)
                                   {
                                       RemFlag[4]  = 0; 
                                       SendParam();
                                       ModeHint(); 
                                       CheckAlarm();
                                       EnterPage(PAGE_MAIN);
                                       StartRem[4] = 0;
                                   }
                               }
                           }
                           else
                           {
                                if(SysParam.RemCtlFlag)
                               {
                                   if(!RemFlag[0])
                                   {
                                       RemFlag[0] = 1;
                                       StartRem[0]++;
                                       EnterPage(PAGE_REM);
                                      
                                   }
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 23  

                               }
                               else
                               {
                                   if(StartRem[0] != 0)
                                   {
                                       RemFlag[0]  = 0; 
                                       SendParam();
               
                                       ModeHint();
               
                                       EnterPage(PAGE_START);
                                       StartRem[0] = 0;
                                   }
                               }
                               break;
                           }
                       }
                       
                       case 1:
                       {
                           if(SysParam.RemCtlFlag)
                           {
                                if(!RemFlag[1])
                               {
                                   RemFlag[1] = 1;
                                   StartRem[1]++;
                                   EnterPage(PAGE_REM);
                                   
                                }
                           }
                           else
                           {
                                if(StartRem[1] != 0)
                               {
                                   
                                   RemFlag[1] = 0;
                                   if(RunStatus.Running)
                                   {
                                       SendParam();
               
                                       ModeHint();
               
                                       CheckAlarm();
               
                                       EnterPage(PAGE_MAIN);
                                   }
                                   else
                                   {
                                       SendParam();
               
                                       ModeHint();
               
                                       UpdataUI();
               
                                       EnterPage(PAGE_MAIN);
               
                                   }
                                   StartRem[1] = 0;
                                }
                           }
                           break;
                       }
                       
                        case 2:
                       {
                           if(SysParam.RemCtlFlag)
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 24  

                           {
                                if(!RemFlag[2])
                               {
                                   RemFlag[2] = 1;
                                   StartRem[2]++;
                                   EnterPage(PAGE_REM);
               
                                  
                                }
                           }
                           else
                           {
                                if(StartRem[2] != 0)
                               {
                                   RemFlag[2] = 0;
                                   SendParam();
               
                                   ModeHint();
               
                                   EnterPage(PAGE_SET);
               
                                   StartRem[2] = 0;
                                }
                           }
                           break;
                       }
                        
                        case 3:
                       {
                           if(SysParam.RemCtlFlag)
                           {
                                if(!RemFlag[3])
                               {
                                   RemFlag[3] = 1;
                                   StartRem[3]++;
                                   EnterPage(PAGE_REM);
               
                                   
                                }
                           }
                           else
                           {
                                if(StartRem[3] != 0)
                               {
                                   RemFlag[3] = 0;
                                   SendParam();
               
                                   ModeHint();
               
                                   EnterPage(PAGE_TIME);
                                   StartRem[3] = 0;
                                }
                           }
                          break; 
                       }  
                   }
               }
               #endif
 1569          
 1570          
 1571          //远程控制读RemCtlTask从机
 1572          void RemCtlTask()
 1573          {   
 1574   1          RemPageCtl();
 1575   1      }
 1576          
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 25  

 1577          void main(void)
 1578          {
 1579   1          SysInit();
 1580   1          IoInit();
 1581   1          PW_MAIN(0);  // 主电源
 1582   1          LedInit();
 1583   1          
 1584   1          RUN_LED(1);
 1585   1         
 1586   1          Delay(200);
 1587   1          
 1588   1          Timer0Init();
 1589   1          Delay(200);
 1590   1          Adc_Init();
 1591   1          Delay(200);
 1592   1          
 1593   1          UART1_config();
 1594   1          UART2_config();
 1595   1          UART3_config();
 1596   1          UART4_config();
 1597   1          ClearUart1Buf();
 1598   1          ClearUart2Buf();
 1599   1          ClearUart3Buf();
 1600   1          ClearUart4Buf();
 1601   1          
 1602   1          // 待CPU稳定了再读参数
 1603   1          Delay(500);
 1604   1          ReadParam();
 1605   1          Delay(200);
 1606   1      
 1607   1          SyncModBusDev();
 1608   1          Delay(200);
 1609   1          
 1610   1          RUN_LED(0);
 1611   1      
 1612   1          #if 0
                   while(1)
                   {
                       RUN_LED(0);
                       Delay(800);
                       RUN_LED(1);
                       Delay(200);
                   }
                   #endif
 1621   1          
 1622   1          
 1623   1          EA = 1;     //打开总中断
 1624   1      
 1625   1          WDT_CONTR |= (1<<5) |  7;  // 启动开门狗，约8秒
 1626   1          
 1627   1          Delay(200);
 1628   1          InitLcd();
 1629   1          SysParam.RemCtlFlag = false;
 1630   1          
 1631   1          PageSwitch = 0;
 1632   1          while(1)
 1633   1          {
 1634   2              TimerTask();
 1635   2              HndInput();
 1636   2            
 1637   2              Uart1Hnd();
 1638   2              Uart2Hnd();
 1639   2              Uart3Hnd(); 
 1640   2              FlowTask();
 1641   2              
 1642   2              Uart4Hnd();
C251 COMPILER V5.60.0,  main                                                               22/05/24  17:23:31  PAGE 26  

 1643   2              RemCtlTask(); 
 1644   2              
 1645   2      
 1646   2          }
 1647   1      }
 1648          
 1649          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      7017     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       297     ------
  xdata-const size     =    ------     ------
  edata size           =       184     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       361     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
