C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\obj\main.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE main.c XSMALL OPTIMIZE(0,SPEED) BROWSE INCDIR(.\Ads1110;.\Flash;.\mcp4
                    -725;.\IIC;.\MwPro;.\Uart;.\Lcd;.\ModBus;.\Temperaturn) PRINT(.\obj\main.lst) OBJECT(.\obj\main.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include "Lcd.h"
    3          #include "LcdApp.h"
    4          #include "ModBus.h"
    5          #include "Temper.h"
    6          #include "FlowMeter.h"
    7          #include "ModBusDev.h"
    8          #include "ModBusHost.h"
    9          
   10          
   11          BYTE code VERSION = 101;  // V1.0.0
   12          
   13          BYTE xdata StrTmp[64] = {0};
   14          //BYTE xdata Valve[8] = {0};
   15          
   16          BYTE ChannelError[FLOW_METER_CNT] ={0};
   17          
   18          #define Log //((CSampDemoDlg *)theApp.m_pMainWnd)->AddLog
   19          
   20          #define PARAM_SIGN  0x3132
   21          SYS_PARAM xdata SysParam;
   22          RUN_STATUS xdata RunStatus;
   23          REM_REGADDR xdata RemRegAddr;
   24          REMRUN_STATUS xdata RemRunStatus;
   25          
   26          float SimFlow = 35.0;
   27          
   28          u16 SendFlowTim = 0;    //读流量计开始时间
   29          BYTE SendFlowFlag = 0;  //读流量计开始标志
   30          
   31          u16 DelayCount = 0;   
   32          BYTE Delayflag = 0;  
   33          
   34          BYTE RemAckOut = 0;    //远程控制从机响应超时标志
   35          u16 RemAckTimout = 0;   //远程控制从机响应超时时间 
   36          
   37          u16 LcdBusyTim = 0;
   38          BYTE LcdBusyFlag = 0;
   39          BYTE ChNum = 1;
   40          
   41          BYTE g_Output[OUT_IO_COUNT]      = {0,0,0,0,0,0,0,0,0,0,0,0,0};   // 上电蓝灯亮
   42          BYTE g_OutStatus[OUT_IO_COUNT]   = {0,0,0,0,0,0,0,0,0,0,0,0,0};
   43          
   44          BYTE PageSwitch = 0;                              //远程控制界面选择
   45          
   46          BYTE RemPage = 0;
   47          BYTE RemStart = 0;
   48          BYTE RemStop = 0;
   49          
   50          // Clear Rem ARM 
   51          BYTE xdata Remchenable[CHANNLE_NUM] = {0};
   52          BOOL xdata Remchflag[CHANNLE_NUM] = {0};
   53          WORD Remchtim = 0;
   54          BOOL ValveIOFlag = false;
   55          BYTE ChannelStop = 0;
   56          
   57          u16  Timer0Cnt = 0;
   58          
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 2   

   59          BYTE g_Key_Confrom  = 0; 
   60          BYTE g_Key_Power  = 0; 
   61          BYTE g_Key_Input  = 0; 
   62          BYTE Input_Status = 0;
   63          
   64          WORD gRunTime = 0;
   65          
   66          void DebugMsg(char *msg)
   67          {
   68   1          BYTE len = (BYTE)strlen(msg);
   69   1          //Uart1Send((BYTE *)msg,len);
   70   1      }
   71          
   72          void DebugInt(int msg)
   73          {
   74   1          memset(StrTmp,0,64);
   75   1          sprintf(StrTmp,"%x\r\n",msg);
   76   1          DebugMsg(StrTmp);
   77   1      }
   78          
   79          void DumpCmd(BYTE *dat, BYTE len)
   80          {
   81   1          BYTE i;
   82   1          memset(StrTmp,0,64);
   83   1          for (i=0;i<len;i++)
   84   1          {
   85   2              if (strlen(StrTmp) >= 60)
   86   2              {
   87   3                  break;
   88   3              }
   89   2              sprintf(&StrTmp[i*3], "%02X ", dat[i]);
   90   2          }
   91   1          sprintf(&StrTmp[i*3], "\r\n");
   92   1          DebugMsg(StrTmp);
   93   1      }
   94          
   95          
   96          void Error()
   97          {
   98   1          while(1)
   99   1          {
  100   2              RUN_LED(1);
  101   2              Delay(50);
  102   2              RUN_LED(0);
  103   2              Delay(50);
  104   2          }
  105   1          
  106   1      }
  107          
  108          
  109          void SysInit()
  110          {
  111   1          HIRCCR = 0x80;           // 启动内部高速IRC
  112   1          while(!(HIRCCR & 1));
  113   1          CLKSEL = 0;              
  114   1      }
  115          
  116          void IoInit()
  117          {
  118   1          EAXFR = 1;
  119   1          WTST = 0;   //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
  120   1      
  121   1          P0M1 = 0x00;   P0M0 |= (1<<4) ;                     // P0.0 P0.1 P0.4 推挽输出
  122   1          P1M1 = (1<<4)|(1<<3);   P1M0 = 0x00;                       //设置为准双向口
  123   1          P2M1 = 0x00;   P2M0 |= 0x00;                      // P2.2 推挽输出
  124   1          P3M1 = 0x00;   P3M0 |= (1<<2)|(1<<3)|(1<<4);        //设置为准双向口
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 3   

  125   1          P4M1 = 0x00;   P4M0 = 0x00;                       //设置为准双向口
  126   1          P5M1 = 0x00;   P5M0 |= (1<<0) | (1<<2);             //设置为准双向口
  127   1          P6M1 = 0x00;   P6M0 |= (1<<7);     //设置为准双向口
  128   1          P7M1 = 0x00;   P7M0 = 0x00;                         //设置为准双向口
  129   1      }
  130          
  131          
  132          void SensorInit()
  133          {
  134   1          // P1.0 -- 下降缘中断
  135   1          P1IM0 = 0;
  136   1          P1IM1 = 0;
  137   1      
  138   1          // 优先级2
  139   1          //PIN_IP  |= (1<<1);
  140   1          PINIPH |= (1<<1);
  141   1          //P1_IP  = 1; // |= (1<<1);
  142   1          //P1_IPH = 1; //|= (1<<1);
  143   1      
  144   1          // 允许中断
  145   1          P1INTE |= (1<<0) | (1<<1) | (1<<4) | (1<<5);
  146   1      }
  147          
  148          
  149          
  150          void Timer0Init()
  151          {
  152   1          AUXR = 0x00;    //Timer0 set as 12T, 16 bits timer auto-reload, 
  153   1          TH0 = (u8)(Timer0_Reload / 256);
  154   1          TL0 = (u8)(Timer0_Reload % 256);
  155   1          ET0 = 1;    //Timer0 interrupt enable
  156   1          TR0 = 1;    //Tiner0 run
  157   1          
  158   1          // 中断优先级3
  159   1          PT0  = 1;
  160   1          PT0H = 1;
  161   1      }
  162          
  163          // 10ms 中断一下
  164          void Timer0Int (void) interrupt 1
  165          {
  166   1          Timer0Cnt ++;
  167   1         
  168   1          if(Delayflag)
  169   1          {
  170   2              DelayCount -= 10;
  171   2              if(!DelayCount)
  172   2              {
  173   3                  Delayflag = 0;
  174   3              }
  175   2          }
  176   1      }
  177          
  178          #if 0
               // 公用中断服务程序
               void CommInt (void) interrupt 13
               {
                   u8 intf =  P1INTF;
                   
                   if (intf)
                   {
                       P1INTF = 0;
               
                       if (intf & (1<<0))  // P1.0 中断
                       {
                           Counter[0] ++;
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 4   

                       }
               
                       if (intf & (1<<1))  // P1.1 中断
                       {
                           Counter[1] ++;
                       }
               
                       if (intf & (1<<4))  // P1.4 中断
                       {
                           Counter[2] ++;
                       }
               
                       if (intf & (1<<5))  // P1.5 中断
                       {
                           Counter[3] ++;
                       }
                   }
                   
               }
               #endif
  211          
  212          //========================================================================
  213          // 函数名称:void OutCtl(alt_u8 id, alt_u8 st)
  214          // 函数功能:IO输出控制 
  215          // 入口参数: @id：控制IO序号 @st：IO口上一个状态
  216          // 函数返回: 无
  217          // 当前版本: VER1.0
  218          // 修改日期: 2023
  219          // 当前作者: 
  220          // 其他备注: 
  221          //========================================================================
  222          
  223          void OutCtl(alt_u8 id, alt_u8 st)
  224          {
  225   1          if (g_OutStatus[id] == st)
  226   1          {
  227   2              return;
  228   2          }
  229   1      
  230   1          g_OutStatus[id] = st;
  231   1          
  232   1          switch(id)
  233   1          {   
  234   2              case LIGHT_BLUE: 
  235   2              {
  236   3                  (st)? BLU_LIGHT(1) : BLU_LIGHT(0); 
  237   3                  break;
  238   3              }
  239   2          
  240   2              case LIGHT_YELLOW: 
  241   2              {
  242   3                  (st)? YEL_LIGHT(1):YEL_LIGHT(0);
  243   3                  break;
  244   3              }
  245   2      
  246   2              case GAS_BUMP:      //泵
  247   2              {
  248   3                  (st)? BUMP_M(1) : BUMP_M(0);
  249   3                  break;
  250   3              }
  251   2      
  252   2              case EX_FAN:        //风扇
  253   2              {
  254   3                  (st)? FANS_M(1) : FANS_M(0);
  255   3                  break;
  256   3              }
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 5   

  257   2      
  258   2              case ALARM_SOUND:   //报警
  259   2              {
  260   3                  (st)? ALARM(1) : ALARM(0);       
  261   3                  break;
  262   3              }
  263   2      
  264   2              case VALVE_0:   
  265   2              {
  266   3                  (st)? VALVE0(1) : VALVE0(0);       
  267   3                  break;
  268   3              }
  269   2      
  270   2              case VALVE_1:   
  271   2              {
  272   3                  (st)? VALVE1(1) : VALVE1(0);       
  273   3                  break;
  274   3              }  
  275   2      
  276   2              case VALVE_2:   
  277   2              {
  278   3                  (st)? VALVE2(1) : VALVE2(0);       
  279   3                  break;
  280   3              }
  281   2      
  282   2              case VALVE_3:   
  283   2              {
  284   3                  (st)? VALVE3(1) : VALVE3(0);       
  285   3                  break;
  286   3              }   
  287   2      
  288   2              case VALVE_4:   
  289   2              {
  290   3                  (st)? VALVE4(1) : VALVE4(0);       
  291   3                  break;
  292   3              }
  293   2      
  294   2              case VALVE_5:   
  295   2              {
  296   3                  (st)? VALVE5(1) : VALVE5(0);       
  297   3                  break;
  298   3              }   
  299   2      
  300   2              case VALVE_6:   
  301   2              {
  302   3                  (st)? VALVE6(1) : VALVE6(0);       
  303   3                  break;
  304   3              }
  305   2      
  306   2              case VALVE_7:   
  307   2              {
  308   3                  (st)? VALVE7(1) : VALVE7(0);       
  309   3                  break;
  310   3              }   
  311   2          }
  312   1      
  313   1          
  314   1      }
  315          
  316          void OutFlash(alt_u8 id)
  317          {
  318   1          static alt_u16 OutTimer[OUT_IO_COUNT] = {0,0,0,0,0,0,0,0,0,0,0,0,0};
  319   1          if (OutTimer[id] ++ > LED_FLASH_TIME/10)
  320   1          {
  321   2              OutTimer[id] = 0;
  322   2              if (g_OutStatus[id] == 1)
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 6   

  323   2              {
  324   3                  OutCtl(id, 0);
  325   3              }
  326   2              else
  327   2              {
  328   3                  OutCtl(id, 1);
  329   3              }
  330   2          }
  331   1      }
  332          
  333          void IoCtlTask()
  334          {
  335   1          alt_u8 i;
  336   1          for (i=0;i<OUT_IO_COUNT;i++)
  337   1          {
  338   2              if (g_Output[i] == 2)
  339   2              {
  340   3                  OutFlash(i);
  341   3              }
  342   2              else
  343   2              {
  344   3                  OutCtl(i, g_Output[i]);
  345   3              }
  346   2          }
  347   1      }
  348          
  349          // 板载指示灯
  350          void RunLed(u16 dt)
  351          {   
  352   1          static u16 tm = 0;
  353   1          u16 to = 3000;
  354   1          tm += dt;
  355   1      
  356   1          if (tm > to)
  357   1          {
  358   2              tm = 0;
  359   2              RUN_LED(0);
  360   2          }
  361   1          else if (tm > (to-100))
  362   1          {
  363   2              RUN_LED(1);
  364   2          }
  365   1      }
  366          
  367          
  368          
  369          void Task1s()
  370          {
  371   1          static BYTE tm = 0;
  372   1      
  373   1          CLR_WDT = 1;  // 喂狗
  374   1          tm++;
  375   1          if(tm == 10)
  376   1          {
  377   2              ADC_Temp();
  378   2              //SyncModBusDev();
  379   2              tm = 0;
  380   2          } 
  381   1          
  382   1          if((tm == 6)||(tm == 3))
  383   1          {
  384   2              GetRetCode();
  385   2          }
  386   1          
  387   1          if(tm == 9)
  388   1          {
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 7   

  389   2              if (RunStatus.Running)
  390   2              {  
  391   3                  DevRun();
  392   3              }
  393   2          }
  394   1      
  395   1      }
  396          
  397          
  398          void TimerTask()
  399          {
  400   1          u16 delta = 0;
  401   1          static u16 Time1s = 0;
  402   1          static u16 RemTime = 0;
  403   1          if (Timer0Cnt)
  404   1          {
  405   2              delta = Timer0Cnt * 10;
  406   2              Timer0Cnt = 0;
  407   2      
  408   2              Time1s += delta;
  409   2              if (Time1s >= 100)
  410   2              {
  411   3                  Time1s = 0;
  412   3                  Task1s();
  413   3              }
  414   2              
  415   2              if (RX2_Cnt > 0)
  416   2              {
  417   3                  Rx2_Timer += delta;
  418   3              }
  419   2      
  420   2              if(RX3_Cnt > 0)
  421   2              {
  422   3                  Rx3_Timer += delta;
  423   3              }
  424   2              
  425   2              if(RX4_Cnt > 0)
  426   2              {
  427   3                  Rx4_Timer += delta;
  428   3                  
  429   3              }
  430   2              
  431   2              SendFlowTim += delta;
  432   2              if(SendFlowTim > 220)
  433   2              {
  434   3                  SendFlowTim = 0;
  435   3                  SendFlowFlag = 1;
  436   3              }
  437   2              
  438   2              if(RemAckOut)
  439   2              {
  440   3                  RemAckTimout += delta;
  441   3                  if(RemAckTimout > 3000)
  442   3                  {
  443   4                      RemAckTimout = 0;
  444   4                      SysParam.RemCtlFlag = false;
  445   4                  }
  446   3                      
  447   3              }  
  448   2              
  449   2              if (gRunTime < 5000)
  450   2              {
  451   3                  gRunTime += delta;
  452   3              }
  453   2      
  454   2              //if (g_CommIdleTime < 300)
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 8   

  455   2              //{
  456   2                  //g_CommIdleTime += delta;
  457   2              //}
  458   2      
  459   2              #ifdef IRDA_FUN
                       if (IrDAStart == 1)
                       {
                           IrDATimer += delta;
                       }
                       #endif
  465   2      
  466   2              RunLed(delta);
  467   2              IoCtlTask();
  468   2              
  469   2              GetValve();
  470   2              if(SysParam.RemCtlFlag)
  471   2              {
  472   3                  ShowRemCh();
  473   3              }
  474   2          }
  475   1      }
  476          
  477          void delay_ms(u16 ms)
  478          {
  479   1          DelayCount = ms;
  480   1          Delayflag = 1;  
  481   1          while(Delayflag);        
  482   1      }
  483          
  484          
  485          void Delay(WORD ms)
  486          {
  487   1          WORD t = 1000;
  488   1          while(ms--)
  489   1          {
  490   2              for (t=0;t<1000;t++) ;
  491   2          }
  492   1      }
  493          
  494          
  495          WORD ParamCheck(BYTE *buf, WORD len)
  496          {
  497   1          WORD dwSum = 0;
  498   1          WORD i;
  499   1      
  500   1          for (i = 0; i < len; i++)
  501   1          {
  502   2              dwSum += buf[i];
  503   2          }
  504   1      
  505   1          return dwSum;
  506   1      }
  507          
  508          /*
  509          void DefSenParam()
  510          {
  511              BYTE i;
  512              for (i=0; i<SENSOR_COUNT; i++)
  513              {
  514                  SysParam.SenParam[i].LOW_REVISE_COE_A = 1;
  515                  SysParam.SenParam[i].LOW_REVISE_COE_B = 1;
  516                  SysParam.SenParam[i].LOW_REVISE_COE_C = 1;
  517          
  518                  SysParam.SenParam[i].HIG_REVISE_COE_A = 1;
  519                  SysParam.SenParam[i].HIG_REVISE_COE_B = 1;
  520                  SysParam.SenParam[i].HIG_REVISE_COE_C = 1;
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 9   

  521          
  522                  SysParam.SenParam[i].SUPER_REVISE_COE_A = 1;
  523                  SysParam.SenParam[i].SUPER_REVISE_COE_B = 1;
  524                  SysParam.SenParam[i].SUPER_REVISE_COE_C = 1;
  525          
  526                  SysParam.SenParam[i].DET_THR_1 = 500;
  527                  SysParam.SenParam[i].DET_THR_2 = 150;
  528                  SysParam.SenParam[i].DET_THR_3 = 150;
  529          
  530                  SysParam.SenParam[i].DET_TIME = 1000;
  531                  SysParam.SenParam[i].HV_THR = 1000;
  532              }
  533          }
  534          */
  535          
  536          /*
  537          void DefSenAlarm()
  538          {
  539              BYTE i;
  540              for (i=0; i<SENSOR_COUNT; i++)
  541              {
  542                  SysParam.AlmParam[i].DOSE_RATE_ALARM_1 = 300;
  543                  SysParam.AlmParam[i].DOSE_RATE_ALARM_2 = 400;
  544                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_1 = 300;
  545                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_2 = 400;
  546                  SysParam.AlmParam[i].INVALID_ALRAM_1 = 8000;
  547                  SysParam.AlmParam[i].INVALID_ALRAM_2 = 10000;
  548              }
  549          }
  550          */
  551          
  552          void ReadParam()
  553          {
  554   1          EEPROM_read(0, (BYTE *)&SysParam, sizeof(SYS_PARAM));
  555   1      
  556   1          #if 0
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(SYS_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_SENSOR_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_ALRAM_PARA));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(float));
                   DebugMsg((char *)StrTmp);
                   
                   //Rs485Send((BYTE *)&SysParam, sizeof(SYS_PARAM));
                   
                   
                   if (SysParam.Sign != PARAM_SIGN)
                   {
                       DebugMsg("Sign error. \r\n");
                   }
               
                   if (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2))
                   {
                       DebugMsg("Param Check error. \r\n");
                   }
                   #endif
  586   1      
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 10  

  587   1         
  588   1          if ( (SysParam.Sign != PARAM_SIGN) ||
  589   1               (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2)) )
  590   1          {
  591   2              //SysParam.Sign = PARAM_SIGN;
  592   2              //SysParam.Address = 1;
  593   2              ParamDef();
  594   2              //DefSenParam();
  595   2              //DefSenAlarm();
  596   2              WriteParam();
  597   2      
  598   2              //DebugMsg("Def Param. \r\n");
  599   2          }
  600   1      }
  601          
  602          
  603          void WriteParam()
  604          {
  605   1          EA = 0;    
  606   1          
  607   1          EEPROM_SectorErase(0);
  608   1          EEPROM_SectorErase(512);
  609   1          SysParam.Sum = ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2);
  610   1          if (!EEPROM_write(0, (BYTE *)&SysParam, sizeof(SYS_PARAM)))
  611   1          {
  612   2              Error();
  613   2          }
  614   1          //printf("Write34= OK\r\n");
  615   1          EA = 1;     //打开总中断
  616   1      }
  617          
  618          BYTE GetInput()
  619          {
  620   1          // 当前只有一个开关机状态 P2.1
  621   1          static BYTE his = LOCK_BIT();
  622   1          BYTE st = POWER_LOCK();
  623   1      
  624   1          if (st != his)
  625   1          {
  626   2              Delay(50);
  627   2              if ( st == POWER_LOCK() )
  628   2              {
  629   3                  his = st;
  630   3                  return st;
  631   3              }
  632   2          }
  633   1      
  634   1          return 0xFF;
  635   1      }
  636          
  637          
  638          void PowerOff()
  639          {
  640   1          PW_MAIN(0);
  641   1      
  642   1          while(1)
  643   1          {
  644   2              ;
  645   2          }
  646   1      }
  647          
  648          void HndInput()
  649          {
  650   1          static bool em = false;
  651   1          if(STOP_M() == 0)
  652   1          {
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 11  

  653   2              Delay(10);
  654   2              if (STOP_M() == 0)
  655   2              {
  656   3                  if (RunStatus.Running)
  657   3                  {
  658   4                      StopSamp(false);
  659   4                  }
  660   3              }
  661   2      
  662   2              if (em == false)
  663   2              {
  664   3                  em = true;
  665   3                  ShowEmStop(em);
  666   3              }
  667   2          }
  668   1          else
  669   1          {
  670   2              if (em)
  671   2              {
  672   3                  em = false;
  673   3                  ShowEmStop(em);
  674   3              }
  675   2          }
  676   1      }
  677          
  678          /*
  679          void ReportInput()
  680          {
  681              BYTE PwOff = POWER_OFF;
  682              
  683              if (g_CommIdleTime > 200)
  684              {
  685                  if (g_Key_Confrom)
  686                  {
  687                      g_Key_Confrom = 0;
  688                      SendPcCmd(0, CMD_CERTAINKEY, NULL, 0);
  689                      return;
  690                  }
  691          
  692                  if (g_Key_Power)
  693                  {
  694                      g_Key_Power = 0;
  695                      SendPcCmd(0, CMD_POWER, &PwOff, 1);
  696                      return;
  697                  }
  698          
  699                  #if 0
  700                  if (g_Key_Input)
  701                  {
  702                      g_Key_Input = 0;
  703                      SendPcCmd(0, CMD_INPUT, &Input_Status, 1);
  704                  }
  705                  #endif
  706              }
  707          }
  708          */
  709          
  710          void LedInit()
  711          {
  712   1          // 初始状态都为0
  713   1      
  714   1          // 指示灯
  715   1          YEL_LIGHT(0);   // 黄灯
  716   1          BLU_LIGHT(0);   // 蓝灯
  717   1          
  718   1          CloseValve();   // 电磁阀
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 12  

  719   1          BUMP_M(0);      // 泵
  720   1          FANS_M(0);      // 风扇
  721   1          ALARM(0);       // 报警音
  722   1      }
  723          
  724          
  725          void ParamDef()
  726          {
  727   1          BYTE i;
  728   1          
  729   1          SysParam.Sign     = PARAM_SIGN;
  730   1          SysParam.Address = 1;
  731   1          SysParam.BkLight = 50;
  732   1      
  733   1          SysParam.SampMode = MODE_TIME;
  734   1          SysParam.SampTime = 5;  
  735   1          SysParam.SampVol   = 2;
  736   1          SysParam.AlarmThres   = 10;
  737   1          for (i=0;i<CHANNLE_NUM;i++)
  738   1          {
  739   2              SysParam.SampFlow[i] = 35;
  740   2              SysParam.Channel_SampMode[i] = MODE_NOCHANNEL;
  741   2              SysParam.Channel_SampFlowVol[i] = 2;
  742   2          }
  743   1      
  744   1          SysParam.Enable = 0x00;
  745   1          SysParam.ChModeCtl = 0x00;
  746   1          SysParam.RemCtlFlag = false;
  747   1          RemRunStatus.RemRun = false; 
  748   1          RemRunStatus.HostRun = true;
  749   1          ChannelStop = 0;
  750   1      }
  751          
  752          void SaveParam()
  753          {
  754   1          //CString t;
  755   1          //t.Format(_T("SaveParam: %02X\r\n"), SysParam.Enable);
  756   1          //Log(t);
  757   1          //DebugMsg("123");
  758   1          WriteParam();
  759   1      }
  760          
  761          
  762          void UpdataUI()
  763          {
  764   1          BYTE i;
  765   1          for (i=0;i<CHANNLE_NUM;i++)
  766   1          {
  767   2              ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
  768   2          }
  769   1          ShowStatus();
  770   1          Delay(200);
  771   1          StatusColor(true);
  772   1      }
  773          
  774          void InitLcd()
  775          {   
  776   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  777   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  778   1          memset(&RealFlow, 0, sizeof(RealFlow));
  779   1          
  780   1          ModeHint();
  781   1          Delay(200);
  782   1          HideModule(MP_HINT_END);
  783   1          Delay(200);
  784   1          UpdataUI();    
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 13  

  785   1          Delay(200);
  786   1          SendParam();
  787   1          Delay(200);
  788   1          SendChannelParam();
  789   1          Delay(200);
  790   1          SetBkLight(false);
  791   1          Delay(200);
  792   1          ShowDevInfo();
  793   1          Delay(200);
  794   1      }
  795          
  796          
  797          void GetFlow()
  798          {
  799   1          BYTE i;
  800   1          WORD  w;
  801   1          DWORD d;
  802   1      
  803   1          
  804   1          for (i=0;i<CHANNLE_NUM;i++)
  805   1          {
  806   2      //        if (SysParam.Enable & (1<<i))
  807   2      //        {
  808   2                  RunStatus.Flow[i] = RealFlow[i].val;  // 模拟 -- 实际要从流量计中读取
  809   2                  w = (WORD)(RunStatus.Flow[i]*10);
  810   2                  RunInfo.ChFlow[i].Flow = SwWord(w);
  811   2                  
  812   2                  RunStatus.Volume[i] =  RealFlow[i].Totol; 
  813   2                  w = (WORD)(RunStatus.Volume[i]*10);
  814   2                  RunInfo.ChFlow[i].Vol = SwWord(w);
  815   2      //        }
  816   2          }
  817   1      
  818   1          // 总流量
  819   1          RunStatus.TotleFlow = RealFlow[8].val;
  820   1          d = (DWORD)(RealFlow[8].val*10);
  821   1          RunInfo.TotFlow.Flow = SwDWord(d);
  822   1      
  823   1          // 总体积
  824   1          RunStatus.TotleVol = RealFlow[8].Totol;
  825   1          d = (DWORD)(RealFlow[8].Totol*10);
  826   1          RunInfo.TotFlow.Vol   = SwDWord(d);
  827   1      }
  828          
  829          void StartSamp()
  830          {
  831   1          BYTE i = 0;
  832   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  833   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  834   1          memset(&RealFlow, 0, sizeof(RealFlow));
  835   1          SysParam.ChModeCtl = 0x00;
  836   1          RemRunStatus.HostRun = true;
  837   1          RunStatus.Running = true;
  838   1          g_Output[LIGHT_BLUE] = 1;
  839   1          //CheckValve();
  840   1          OpenPump();
  841   1          memcpy(HisAlarm,ChannelAlarm,CHANNLE_NUM);
  842   1          ShowStatus();
  843   1          StatusColor(true);
  844   1          //g_Output[ALARM_SOUND] = 0; 
  845   1      
  846   1          if(!SysParam.RemCtlFlag)
  847   1          {
  848   2              SetStartBtn(0);
  849   2          }
  850   1      
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 14  

  851   1      }
  852          
  853          void StopSamp(bool Auto)
  854          {
  855   1          BYTE i = 0;
  856   1          ClosePump();
  857   1          memset(RealFlow,0, sizeof(RealFlow));
  858   1          ChannelStop = 0;
  859   1          RunStatus.Running = false;
  860   1          g_Output[LIGHT_BLUE] = 0;
  861   1          g_Output[LIGHT_YELLOW] = 0; 
  862   1          g_Output[ALARM_SOUND] = 0; 
  863   1          for (i=0;i<CHANNLE_NUM;i++)
  864   1          {
  865   2              ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
  866   2          }
  867   1         
  868   1          if(!SysParam.RemCtlFlag)
  869   1          {
  870   2              SetStartBtn(1);  // 按钮自动变为“开始”
  871   2          }
  872   1          if (Auto)  // 自动结束
  873   1          {
  874   2              // 显示取样结束提示框
  875   2              ShowModule(MP_HINT_END, REG_HINT_END);
  876   2              //Delay(200);
  877   2          }
  878   1          SaveParam();
  879   1      }
  880          
  881          
  882          void CheckModeStop()
  883          {
  884   1          BYTE i = 0;
  885   1          static BYTE sta = 0; 
  886   1          if(SysParam.Enable == 0)
  887   1          {
  888   2              RemRunStatus.HostRun = false;
  889   2              if(SysParam.RemCtlFlag)
  890   2              {
  891   3                  StopSamp(false);
  892   3              }
  893   2              else
  894   2              {
  895   3                  StopSamp(true);
  896   3              }
  897   2          }
  898   1      }
  899          
  900          // 定时模式
  901          void TimingMode()
  902          {
  903   1          BYTE i = 0,j = 0;
  904   1          for(i = 0;i<CHANNLE_NUM;i++)
  905   1          {
  906   2             
  907   2              if(SysParam.Channel_SampMode[i] == MODE_VOL)
  908   2              {
  909   3                  if(RunStatus.Volume[i] >= (SysParam.Channel_SampFlowVol[i]))
  910   3                  {
  911   4                       if(!SysParam.RemCtlFlag)
  912   4                      {
  913   5                          SysParam.Enable &= ~(1<<i);   
  914   5                      }               
  915   4                      SysParam.ChModeCtl |= (1<<i);
  916   4                      
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 15  

  917   4                  }
  918   3              }
  919   2              else if(SysParam.Channel_SampMode[i] == MODE_TIME)
  920   2              {
  921   3                  if (RunStatus.RunTime[i] >= (SysParam.Channel_SampFlowVol[i]) * 60)
  922   3                  {
  923   4                          if(!SysParam.RemCtlFlag)
  924   4                      {
  925   5                          SysParam.Enable &= ~(1<<i);
  926   5                          }
  927   4                      SysParam.ChModeCtl |= (1<<i);
  928   4                  }
  929   3              }
  930   2              else
  931   2              {
  932   3                  if (RunStatus.RunTime[8] >= ((DWORD)SysParam.SampTime) * 60)
  933   3                  {
  934   4                      if(!SysParam.RemCtlFlag)
  935   4                      {
  936   5                          SysParam.Enable &= ~(1<<i);
  937   5                          }
  938   4                      SysParam.ChModeCtl |= (1<<i);
  939   4      
  940   4                  }
  941   3              }
  942   2          }
  943   1          CheckModeStop();
  944   1      }
  945          
  946          void Channel_ManMode()
  947          {
  948   1          BYTE i = 0;
  949   1          for(i = 0;i<CHANNLE_NUM;i++)
  950   1          {
  951   2              if(SysParam.Channel_SampMode[i] == MODE_VOL)
  952   2              {
  953   3                  if(RunStatus.Volume[i] >= (SysParam.Channel_SampFlowVol[i]))
  954   3                  {
  955   4                      if(!SysParam.RemCtlFlag)
  956   4                      {
  957   5                          SysParam.Enable &= ~(1<<i);
  958   5                          }
  959   4                      SysParam.ChModeCtl |= (1<<i);
  960   4                  }
  961   3              }
  962   2              else if(SysParam.Channel_SampMode[i] == MODE_TIME)
  963   2              {
  964   3                  if (RunStatus.RunTime[8] >= (SysParam.Channel_SampFlowVol[i]) * 60)
  965   3                  {
  966   4                      if(!SysParam.RemCtlFlag)
  967   4                      {
  968   5                          SysParam.Enable &= ~(1<<i);
  969   5                          }
  970   4                      SysParam.ChModeCtl |= (1<<i);
  971   4                  }
  972   3              }
  973   2          }
  974   1          CheckModeStop();
  975   1      }
  976          
  977          // 定量模式
  978          void VolumeMode()
  979          {
  980   1          BYTE i = 0,j = 0;
  981   1          for(i = 0;i<CHANNLE_NUM;i++)
  982   1          {
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 16  

  983   2              
  984   2              if(SysParam.Channel_SampMode[i] == MODE_VOL)
  985   2              {
  986   3                  if(RunStatus.Volume[i] >= (SysParam.Channel_SampFlowVol[i]))
  987   3                  {
  988   4                      if(!SysParam.RemCtlFlag)
  989   4                      {
  990   5                          SysParam.Enable &= ~(1<<i);
  991   5                          }
  992   4                      SysParam.ChModeCtl |= (1<<i);
  993   4                  }
  994   3              }
  995   2              else if(SysParam.Channel_SampMode[i] == MODE_TIME)
  996   2              {
  997   3                  if (RunStatus.RunTime[i] >= (SysParam.Channel_SampFlowVol[i]) * 60)
  998   3                  {
  999   4                      if(!SysParam.RemCtlFlag)
 1000   4                      {
 1001   5                          SysParam.Enable &= ~(1<<i);
 1002   5                          }
 1003   4                      SysParam.ChModeCtl |= (1<<i);
 1004   4                  }
 1005   3              }
 1006   2              else
 1007   2              {
 1008   3                  //ChannelStop |= (1<<i);
 1009   3                  if (RunStatus.Volume[i] >= SysParam.SampVol)
 1010   3                  {
 1011   4                      if(!SysParam.RemCtlFlag)
 1012   4                      {
 1013   5                          SysParam.Enable &= ~(1<<i);
 1014   5                          }
 1015   4                      SysParam.ChModeCtl |= (1<<i);
 1016   4                  }
 1017   3              }
 1018   2          }
 1019   1          CheckModeStop();
 1020   1      }
 1021          
 1022          
 1023          void RunCheck()
 1024          {
 1025   1          switch (SysParam.SampMode)
 1026   1          {
 1027   2              case MODE_TIME:  TimingMode();  break;
 1028   2              case MODE_VOL:   VolumeMode();  break;
 1029   2              default: Channel_ManMode();break;
 1030   2          }
 1031   1          //Delay(200);
 1032   1          SendParam();
 1033   1          
 1034   1      //    SendChannelParam();
 1035   1      //    Delay(200);
 1036   1      }
 1037          
 1038          void AbnorAlaerm()
 1039          {   
 1040   1          BYTE i;
 1041   1          bool HaveAlarm = false;
 1042   1      
 1043   1          for(i = 0;i < CHANNLE_NUM;i++)
 1044   1          {
 1045   2              if( (ChannelAlarm[i] == ALM_FLOW_ABNOR) ||
 1046   2                  (ChannelAlarm[i] ==  ALM_FLOW_LOW) || 
 1047   2                  (ChannelAlarm[i] == ALM_FLOW_HIGH)  )
 1048   2              {
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 17  

 1049   3                  HaveAlarm = true;
 1050   3                  break;
 1051   3              }
 1052   2          }
 1053   1      
 1054   1          if (HaveAlarm)
 1055   1          {
 1056   2              //printf("HAveALM_true\r\n");
 1057   2              g_Output[LIGHT_YELLOW] = 1;
 1058   2              g_Output[ALARM_SOUND] = 2;
 1059   2          }
 1060   1          else
 1061   1          {
 1062   2              //printf("HAveALM_false\r\n");
 1063   2              g_Output[LIGHT_YELLOW] = 0;
 1064   2              g_Output[ALARM_SOUND] = 0;
 1065   2          }
 1066   1      }
 1067          void CheckAlarm()
 1068          {
 1069   1          BYTE i;
 1070   1          float flow = 0;
 1071   1          static BYTE time[8] = {0};
 1072   1          for (i=0;i<CHANNLE_NUM;i++)
 1073   1          {
 1074   2              if (SysParam.Enable & (1<<i))
 1075   2              {
 1076   3                  if(Remchflag[i])
 1077   3                  {
 1078   4                      time[i]++;
 1079   4                      if(time[i] > 2)
 1080   4                      {
 1081   5                          time[i] = 0;
 1082   5                          Remchflag[i] = false;
 1083   5                          flow = RunStatus.Flow[i];
 1084   5                          if (flow > SysParam.SampFlow[i]*(100+SysParam.AlarmThres)/100)
 1085   5                          {
 1086   6                              ChannelAlarm[i] = ALM_FLOW_HIGH;
 1087   6                          }
 1088   5                          else if (flow < SysParam.SampFlow[i]*(100-SysParam.AlarmThres)/100)
 1089   5                          {
 1090   6                              ChannelAlarm[i] = ALM_FLOW_LOW;
 1091   6                          }
 1092   5                          else
 1093   5                          {
 1094   6                              ChannelAlarm[i] = ALM_FLOW_NOR;
 1095   6                          }
 1096   5                      }
 1097   4                  }
 1098   3                  else
 1099   3                  {    
 1100   4                      flow = RunStatus.Flow[i];
 1101   4                      if (flow > SysParam.SampFlow[i]*(100+SysParam.AlarmThres)/100)
 1102   4                      {
 1103   5                          ChannelAlarm[i] = ALM_FLOW_HIGH;
 1104   5                      }
 1105   4                      else if (flow < SysParam.SampFlow[i]*(100-SysParam.AlarmThres)/100)
 1106   4                      {
 1107   5                          ChannelAlarm[i] = ALM_FLOW_LOW;
 1108   5                      }
 1109   4                      else
 1110   4                      {
 1111   5                          ChannelAlarm[i] = ALM_FLOW_NOR;
 1112   5                      }
 1113   4                  }
 1114   3                  
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 18  

 1115   3              }
 1116   2              else
 1117   2              {
 1118   3                  ChannelAlarm[i] = ALM_CH_DISABLE;
 1119   3              }
 1120   2              
 1121   2              if( (ChannelError[i] > 3) && (ChannelAlarm[i] != ALM_CH_DISABLE) )
 1122   2              {
 1123   3                  ChannelAlarm[i] = ALM_FLOW_ABNOR;
 1124   3              }
 1125   2          }
 1126   1          if (memcmp(HisAlarm,ChannelAlarm,CHANNLE_NUM) != 0)
 1127   1          {
 1128   2              // 报警有变化才更新界面
 1129   2              Delay(200);
 1130   2              ShowStatus();
 1131   2              Delay(200);
 1132   2              AbnorAlaerm();
 1133   2              StatusColor(false);
 1134   2      
 1135   2              memcpy(HisAlarm,ChannelAlarm,8);
 1136   2          }
 1137   1      }
 1138          
 1139          // 1秒运行一次
 1140          void DevRun()
 1141          {
 1142   1          BYTE i = 0;
 1143   1          RunStatus.RunTime[8] ++;
 1144   1          for(i = 0;i<CHANNLE_NUM;i++)
 1145   1          {
 1146   2              if(SysParam.Enable &(1<<i))
 1147   2              {
 1148   3                  RunStatus.RunTime[i] ++;
 1149   3              }
 1150   2          }
 1151   1          
 1152   1          // 1. 获取流量
 1153   1          GetFlow();
 1154   1      
 1155   1          // 2. 显示流量和状态
 1156   1          ShowFlow();
 1157   1      
 1158   1          // 4. 根据模式判断是否结束取样
 1159   1          RunCheck();
 1160   1          
 1161   1          // 3. 检查报警状态  
 1162   1          if (RunStatus.RunTime[8] > 10)
 1163   1          {
 1164   2              // 运行时间大于10秒才检测
 1165   2              CheckAlarm();
 1166   2          }
 1167   1          
 1168   1      
 1169   1      //    SendParam();
 1170   1      //    SendChannelParam();
 1171   1      }
 1172          
 1173          
 1174          //获取电磁阀状态
 1175          void GetValve()
 1176          {
 1177   1          BYTE i;
 1178   1          for(i = 0;i<CHANNLE_NUM;i++)
 1179   1          {
 1180   2              if(SysParam.Enable & (1<<i))
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 19  

 1181   2              {
 1182   3                  RemChStatus[i] = 1;
 1183   3                 
 1184   3              }
 1185   2              else
 1186   2              {
 1187   3                  RemChStatus[i] = 0; 
 1188   3                  RunStatus.RunTime[i] = 0;
 1189   3                  RealFlow[i].Totol = 0;
 1190   3              }
 1191   2              if(SysParam.RemCtlFlag)
 1192   2              {
 1193   3                  if(Remchenable[i] != RemChStatus[i])
 1194   3                  {
 1195   4                      Remchenable[i] = RemChStatus[i];
 1196   4                      Remchflag[i] = true;
 1197   4                  }
 1198   3              }
 1199   2          }
 1200   1          
 1201   1              CheckValve();
 1202   1      }
 1203          
 1204          //查询电磁阀状态
 1205          void CheckValve()
 1206          {
 1207   1          BYTE i;
 1208   1          for(i = 0;i<CHANNLE_NUM;i++)
 1209   1          {
 1210   2              if(RemChStatus[i])
 1211   2              {
 1212   3                  switch(i)
 1213   3                  {                            
 1214   4                      case 0 : g_Output[VALVE_0] = 1; break;
 1215   4                      case 1 : g_Output[VALVE_1] = 1; break;
 1216   4                      case 2 : g_Output[VALVE_2] = 1; break;
 1217   4                      case 3 : g_Output[VALVE_3] = 1; break;
 1218   4                      case 4 : g_Output[VALVE_4] = 1; break;
 1219   4                      case 5 : g_Output[VALVE_5] = 1; break;
 1220   4                      case 6 : g_Output[VALVE_6] = 1; break;
 1221   4                      case 7 : g_Output[VALVE_7] = 1; break;  
 1222   4                  }
 1223   3              }
 1224   2              else
 1225   2              {
 1226   3                  switch(i)
 1227   3                  {
 1228   4                      case 0 : g_Output[VALVE_0] = 0; break;
 1229   4                      case 1 : g_Output[VALVE_1] = 0; break;
 1230   4                      case 2 : g_Output[VALVE_2] = 0; break;
 1231   4                      case 3 : g_Output[VALVE_3] = 0; break;
 1232   4                      case 4 : g_Output[VALVE_4] = 0; break;
 1233   4                      case 5 : g_Output[VALVE_5] = 0; break;
 1234   4                      case 6 : g_Output[VALVE_6] = 0; break;
 1235   4                      case 7 : g_Output[VALVE_7] = 0; break;  
 1236   4                  }
 1237   3              }
 1238   2          }
 1239   1      }
 1240          
 1241          //关闭电磁阀
 1242          void CloseValve()
 1243          {
 1244   1          VALVE0(0);
 1245   1          VALVE1(0);
 1246   1          VALVE2(0);
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 20  

 1247   1          VALVE3(0);
 1248   1          VALVE4(0);
 1249   1          VALVE5(0);
 1250   1          VALVE6(0);
 1251   1          VALVE7(0);
 1252   1      }
 1253          // 开启气泵
 1254          void OpenPump()
 1255          {
 1256   1          g_Output[GAS_BUMP] = 1;
 1257   1      }
 1258          
 1259          
 1260          // 停止气泵
 1261          void ClosePump()
 1262          {
 1263   1          //CloseValve();
 1264   1          g_Output[GAS_BUMP] = 0;
 1265   1      }
 1266          
 1267          void SendReadFlowCmd(BYTE ch)
 1268          {
 1269   1          ChannelError[ch-1] ++;
 1270   1          SendReadFlow(ch);    
 1271   1      }
 1272          
 1273          BYTE GetAlarm(BYTE i)
 1274          {
 1275   1          if(ChannelAlarm[i] == ALM_CH_DISABLE)
 1276   1          {
 1277   2              return ALM_CH_DISABLE;
 1278   2          }
 1279   1          else if (ChannelAlarm[i] ==  ALM_FLOW_ABNOR)
 1280   1          {
 1281   2              return ALM_FLOW_ABNOR;
 1282   2          }
 1283   1          
 1284   1          else if (ChannelAlarm[i] ==  ALM_FLOW_HIGH)
 1285   1          {
 1286   2              return ALM_FLOW_HIGH;
 1287   2          }
 1288   1      
 1289   1          else if (ChannelAlarm[i] ==  ALM_FLOW_LOW)
 1290   1          {
 1291   2              return ALM_FLOW_LOW;
 1292   2          }
 1293   1          else
 1294   1          {
 1295   2              return ALM_FLOW_NOR;
 1296   2          }
 1297   1      }
 1298          
 1299          void SyncModBusDev()
 1300          {
 1301   1          BYTE i;
 1302   1          memset(&ModBusParam, 0, sizeof(MODBUS_PARAM));
 1303   1          ModBusParam.Addr = RemRegAddr.SypAddr;
 1304   1          ModBusParam.ChModeCtl = SysParam.ChModeCtl;
 1305   1          ModBusParam.RunStatus = RemRunStatus.HostRun;
 1306   1          for(i = 0;i < 8;i++)    
 1307   1          {
 1308   2              ModBusParam.Alarm[i] = GetAlarm(i);
 1309   2          }
 1310   1          ModBusParam.Address = 2;
 1311   1      }
 1312          void FlowTask()
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 21  

 1313          {
 1314   1          if (RunStatus.Running)
 1315   1          {
 1316   2              if(SendFlowFlag == 1)
 1317   2              {
 1318   3                  SendFlowFlag = 0;
 1319   3                  SendReadFlowCmd(ChNum++);
 1320   3              }
 1321   2              
 1322   2              if (ChNum>9)
 1323   2              {
 1324   3                  ChNum = 1;
 1325   3              }
 1326   2          }
 1327   1      }
 1328          
 1329          void RemPageCtl()
 1330          {
 1331   1          BYTE i = 0;
 1332   1          if(SysParam.RemCtlFlag)
 1333   1          {     
 1334   2              if(!RemPage)
 1335   2              {
 1336   3                  RemPage = 1;
 1337   3                  EnterPage(PAGE_REM);
 1338   3              }
 1339   2             if(RemRunStatus.RemRun)
 1340   2             {
 1341   3                  RemStop = 0;
 1342   3                  if(RemStart == 0)
 1343   3                  {
 1344   4                      StartSamp();
 1345   4                      RemStart++;
 1346   4                  }
 1347   3              }
 1348   2             else
 1349   2             {
 1350   3                  RemStart = 0;
 1351   3                  
 1352   3                  if(RemStop == 0)
 1353   3                  {    
 1354   4                      RemRunStatus.HostRun = true;
 1355   4                      g_Output[ALARM_SOUND] = 0; 
 1356   4                      memset(&RunStatus, 0, sizeof(RUN_STATUS));
 1357   4                      StopSamp(false);
 1358   4                      SendParam();
 1359   4                      //SendChannelParam();
 1360   4                      ModeHint(); 
 1361   4                      
 1362   4                      RemStop++;
 1363   4                  }
 1364   3              }
 1365   2          }     
 1366   1          else
 1367   1          {
 1368   2              RemStart = 0;
 1369   2              RemStop = 0;
 1370   2              for (i=0;i<CHANNLE_NUM;i++)
 1371   2              {
 1372   3                  Remchflag[i] = false;
 1373   3              }
 1374   2              
 1375   2              if(RemPage)
 1376   2              {   
 1377   3                  RemPage = 0; 
 1378   3                  RemRunStatus.RemRun = false;
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 22  

 1379   3                  SysParam.ChModeCtl = 0x00;
 1380   3                  
 1381   3                  ClosePump();
 1382   3                  memset(&RunStatus, 0, sizeof(RUN_STATUS));
 1383   3                  memset(RealFlow,0, sizeof(RealFlow));
 1384   3                  for(i=0;i<CHANNLE_NUM;i++)
 1385   3                  {
 1386   4                      ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
 1387   4                  }
 1388   3                  g_Output[ALARM_SOUND] = 0; 
 1389   3                  g_Output[LIGHT_BLUE] = 0; 
 1390   3                  g_Output[LIGHT_YELLOW] = 0;
 1391   3                  SendParam();
 1392   3                  //SendChannelParam();
 1393   3                  ModeHint(); 
 1394   3                  EnterPage(PAGE_START);
 1395   3              } 
 1396   2          }
 1397   1      }
 1398          
 1399          
 1400          #if 0
               //远程控制界面切换
               void RemPageCtl()
               {
                   switch(PageSwitch)
                   {
                       case 0:
                       {
                           if(RunStatus.Running)
                           {
                               if(SysParam.RemCtlFlag)
                               {
                                   if(!RemFlag[4])
                                   {
                                       RemFlag[4] = 1;
                                       StartRem[4]++;
                                       EnterPage(PAGE_REM);
                                      
                                   }
                               }
                               else
                               {
                                   if(StartRem[4] != 0)
                                   {
                                       RemFlag[4]  = 0; 
                                       SendParam();
                                       ModeHint(); 
                                       CheckAlarm();
                                       EnterPage(PAGE_MAIN);
                                       StartRem[4] = 0;
                                   }
                               }
                           }
                           else
                           {
                                if(SysParam.RemCtlFlag)
                               {
                                   if(!RemFlag[0])
                                   {
                                       RemFlag[0] = 1;
                                       StartRem[0]++;
                                       EnterPage(PAGE_REM);
                                      
                                   }
                               }
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 23  

                               else
                               {
                                   if(StartRem[0] != 0)
                                   {
                                       RemFlag[0]  = 0; 
                                       SendParam();
               
                                       ModeHint();
               
                                       EnterPage(PAGE_START);
                                       StartRem[0] = 0;
                                   }
                               }
                               break;
                           }
                       }
                       
                       case 1:
                       {
                           if(SysParam.RemCtlFlag)
                           {
                                if(!RemFlag[1])
                               {
                                   RemFlag[1] = 1;
                                   StartRem[1]++;
                                   EnterPage(PAGE_REM);
                                   
                                }
                           }
                           else
                           {
                                if(StartRem[1] != 0)
                               {
                                   
                                   RemFlag[1] = 0;
                                   if(RunStatus.Running)
                                   {
                                       SendParam();
               
                                       ModeHint();
               
                                       CheckAlarm();
               
                                       EnterPage(PAGE_MAIN);
                                   }
                                   else
                                   {
                                       SendParam();
               
                                       ModeHint();
               
                                       UpdataUI();
               
                                       EnterPage(PAGE_MAIN);
               
                                   }
                                   StartRem[1] = 0;
                                }
                           }
                           break;
                       }
                       
                        case 2:
                       {
                           if(SysParam.RemCtlFlag)
                           {
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 24  

                                if(!RemFlag[2])
                               {
                                   RemFlag[2] = 1;
                                   StartRem[2]++;
                                   EnterPage(PAGE_REM);
               
                                  
                                }
                           }
                           else
                           {
                                if(StartRem[2] != 0)
                               {
                                   RemFlag[2] = 0;
                                   SendParam();
               
                                   ModeHint();
               
                                   EnterPage(PAGE_SET);
               
                                   StartRem[2] = 0;
                                }
                           }
                           break;
                       }
                        
                        case 3:
                       {
                           if(SysParam.RemCtlFlag)
                           {
                                if(!RemFlag[3])
                               {
                                   RemFlag[3] = 1;
                                   StartRem[3]++;
                                   EnterPage(PAGE_REM);
               
                                   
                                }
                           }
                           else
                           {
                                if(StartRem[3] != 0)
                               {
                                   RemFlag[3] = 0;
                                   SendParam();
               
                                   ModeHint();
               
                                   EnterPage(PAGE_TIME);
                                   StartRem[3] = 0;
                                }
                           }
                          break; 
                       }  
                   }
               }
               #endif
 1568          
 1569          
 1570          //远程控制读RemCtlTask从机
 1571          void RemCtlTask()
 1572          {   
 1573   1          RemPageCtl();
 1574   1      }
 1575          
 1576          void main(void)
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 25  

 1577          {
 1578   1          SysInit();
 1579   1          IoInit();
 1580   1          PW_MAIN(0);  // 主电源
 1581   1          LedInit();
 1582   1          
 1583   1          RUN_LED(1);
 1584   1         
 1585   1          Delay(200);
 1586   1          
 1587   1          Timer0Init();
 1588   1          Delay(200);
 1589   1          Adc_Init();
 1590   1          Delay(200);
 1591   1          
 1592   1          UART1_config();
 1593   1          UART2_config();
 1594   1          UART3_config();
 1595   1          UART4_config();
 1596   1          ClearUart1Buf();
 1597   1          ClearUart2Buf();
 1598   1          ClearUart3Buf();
 1599   1          ClearUart4Buf();
 1600   1          
 1601   1          // 待CPU稳定了再读参数
 1602   1          Delay(500);
 1603   1          ReadParam();
 1604   1          Delay(200);
 1605   1      
 1606   1          SyncModBusDev();
 1607   1          Delay(200);
 1608   1          
 1609   1          RUN_LED(0);
 1610   1      
 1611   1          #if 0
                   while(1)
                   {
                       RUN_LED(0);
                       Delay(800);
                       RUN_LED(1);
                       Delay(200);
                   }
                   #endif
 1620   1          
 1621   1          
 1622   1          EA = 1;     //打开总中断
 1623   1      
 1624   1          WDT_CONTR |= (1<<5) |  7;  // 启动开门狗，约8秒
 1625   1          
 1626   1          Delay(200);
 1627   1          InitLcd();
 1628   1          SysParam.RemCtlFlag = false;
 1629   1          
 1630   1          PageSwitch = 0;
 1631   1          while(1)
 1632   1          {
 1633   2              TimerTask();
 1634   2              HndInput();
 1635   2            
 1636   2              Uart1Hnd();
 1637   2              Uart2Hnd();
 1638   2              Uart3Hnd(); 
 1639   2              FlowTask();
 1640   2              
 1641   2              Uart4Hnd();
 1642   2              RemCtlTask(); 
C251 COMPILER V5.60.0,  main                                                               30/05/24  09:54:00  PAGE 26  

 1643   2              
 1644   2      
 1645   2          }
 1646   1      }
 1647          
 1648          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      7029     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       297     ------
  xdata-const size     =    ------     ------
  edata size           =       184     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       361     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
